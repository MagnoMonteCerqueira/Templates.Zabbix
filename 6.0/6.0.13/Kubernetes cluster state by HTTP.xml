<?xml version="1.0" encoding="UTF-8"?>
<zabbix_export><version>6.0</version><date>2023-02-11T16:15:08Z</date><groups><group><uuid>a571c0d144b14fd4a87a9d9b2aa9fcd6</uuid><name>Templates/Applications</name></group></groups><templates><template><uuid>07695028a2ba4b66a5414797bec791df</uuid><template>Kubernetes cluster state by HTTP</template><name>Kubernetes cluster state by HTTP</name><description>Get Kubernetes state metrics by HTTP.
Metrics are collected by requests to Kubernetes API.

Don't forget to read the README.md for the correct setup of the template.

You can discuss this template or leave feedback on our forum https://www.zabbix.com/forum/zabbix-suggestions-and-feedback

Template tooling version used: 0.41</description><groups><group><name>Templates/Applications</name></group></groups><items><item><uuid>41c79d9286734cc3b0e3aa5ef729e5fe</uuid><name>Kubernetes: Get component statuses</name><type>HTTP_AGENT</type><key>kube.componentstatuses</key><history>0</history><trends>0</trends><value_type>TEXT</value_type><preprocessing><step><type>CHECK_NOT_SUPPORTED</type><parameters><parameter/></parameters></step></preprocessing><timeout>10s</timeout><url>{$KUBE.API.URL}{$KUBE.API.COMPONENTSTATUSES.ENDPOINT}</url><status_codes>200, 403</status_codes><headers><header><name>Authorization</name><value>Bearer {$KUBE.API.TOKEN}</value></header></headers><tags><tag><tag>component</tag><value>raw</value></tag></tags></item><item><uuid>e40b126a0cf64ce6bfed3b3de1d4dfa8</uuid><name>Kubernetes: Control plane LLD</name><type>SCRIPT</type><key>kube.control_plane.lld</key><history>0</history><trends>0</trends><value_type>TEXT</value_type><params>var Kube = {
    params: {},

    setParams: function (params) {
        ['api_endpoint', 'token'].forEach(function (field) {
            if (typeof params !== 'object' || typeof params[field] === 'undefined'
                || params[field] === '') {
                throw 'Required param is not set: &quot;' + field + '&quot;.';
            }
        });

        Kube.params = params;
        if (typeof Kube.params.api_endpoint === 'string' &amp;&amp; !Kube.params.api_endpoint.endsWith('/')) {
            Kube.params.api_endpoint += '/';
        }
    },

    request: function (query) {
        var response,
            request = new HttpRequest(),
            url = Kube.params.api_endpoint + query;

        request.addHeader('Content-Type: application/json');
        request.addHeader('Authorization: Bearer ' + Kube.params.token);

        Zabbix.log(4, '[ Kubernetes ] Sending request: ' + url);

        response = request.get(url);

        Zabbix.log(4, '[ Kubernetes ] Received response with status code ' + request.getStatus() + ': ' + response);

        if (request.getStatus() &lt; 200 || request.getStatus() &gt;= 300) {
            throw 'Request failed with status code ' + request.getStatus() + ': ' + response;
        }

        if (response !== null) {
            try {
                response = JSON.parse(response);
            }
            catch (error) {
                throw 'Failed to parse response received from Kubernetes API. Check debug log for more information.';
            }
        }

        return {
            status: request.getStatus(),
            response: response
        };
    },

    getNodes: function () {
        var result = Kube.request('v1/nodes');

        if (typeof result.response !== 'object'
            || typeof result.response.items === 'undefined'
            || result.status != 200) {
            throw 'Cannot get nodes from Kubernetes API. Check debug log for more information.';
        };

        return result.response;
    },
};

try {
    Kube.setParams(JSON.parse(value));

    var nodes = Kube.getNodes(),
        controlPlaneNodes = [],
        api_url = '{$KUBE.API.URL}',
        hostname = api_url.match(/\/\/(.+):/);

    if (typeof hostname[1] === 'undefined') {
            Zabbix.log(4, '[ Kubernetes ] Received incorrect Kubernetes API url: ' + api_url + '. Expected format: &lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;');
            throw 'Cannot get hostname from Kubernetes API url. Check debug log for more information.';
        };

    for (idx in nodes.items) {
        for (label in nodes.items[idx].metadata.labels) {
            if (label === 'node-role.kubernetes.io/control-plane') {                          
                var internalIPs = nodes.items[idx].status.addresses.filter(function (addr) {
                    return addr.type === 'InternalIP';
                });

                var internalIP = internalIPs.length &amp;&amp; internalIPs[0].address;
                controlPlaneNodes.push({
                    '{#NAME}': nodes.items[idx].metadata.name,
                    '{#IP}': internalIP,
                    '{#KUBE.API.SERVER.URL}': Kube.params.api_server_scheme + '://' + ((/(\d+.){3}\d+/.test(internalIP)) ? internalIP : '['+internalIP+']') + ':' + Kube.params.api_server_port + '/metrics',
                    '{#KUBE.CONTROLLER.SERVER.URL}': Kube.params.controller_scheme + '://' + ((/(\d+.){3}\d+/.test(internalIP)) ? internalIP : '['+internalIP+']') + ':' + Kube.params.controller_port + '/metrics',
                    '{#KUBE.SCHEDULER.SERVER.URL}': Kube.params.scheduler_scheme + '://' + ((/(\d+.){3}\d+/.test(internalIP)) ? internalIP : '['+internalIP+']') + ':' + Kube.params.scheduler_port + '/metrics',
                    '{#COMPONENT.API}' : 'API',
                    '{#COMPONENT.CONTROLLER}' : 'Controller manager',
                    '{#COMPONENT.SCHEDULER}' : 'Scheduler',
                    '{#CLUSTER_HOSTNAME}': hostname[1]
                });

                break;
            }
        }
    }

    return JSON.stringify(controlPlaneNodes);
}
catch (error) {
    error += (String(error).endsWith('.')) ? '' : '.';
    Zabbix.log(3, '[ Kubernetes ] ERROR: ' + error);
    return JSON.stringify({ error: error });
}</params><description>Generation of data for Control plane discovery rules.</description><preprocessing><step><type>DISCARD_UNCHANGED_HEARTBEAT</type><parameters><parameter>3h</parameter></parameters></step></preprocessing><timeout>10s</timeout><parameters><parameter><name>token</name><value>{$KUBE.API.TOKEN}</value></parameter><parameter><name>api_server_scheme</name><value>{$KUBE.API_SERVER.SCHEME}</value></parameter><parameter><name>api_server_port</name><value>{$KUBE.API_SERVER.PORT}</value></parameter><parameter><name>controller_scheme</name><value>{$KUBE.CONTROLLER_MANAGER.SCHEME}</value></parameter><parameter><name>controller_port</name><value>{$KUBE.CONTROLLER_MANAGER.PORT}</value></parameter><parameter><name>scheduler_scheme</name><value>{$KUBE.SCHEDULER.SCHEME}</value></parameter><parameter><name>scheduler_port</name><value>{$KUBE.SCHEDULER.PORT}</value></parameter><parameter><name>api_endpoint</name><value>{$KUBE.API.URL}/api</value></parameter></parameters><tags><tag><tag>component</tag><value>raw</value></tag></tags></item><item><uuid>6f22e81d69d04eeca88a7992463556a7</uuid><name>Kubernetes: CronJob count</name><type>DEPENDENT</type><key>kube.cronjob.count</key><delay>0</delay><history>7d</history><description>Number of cronjobs.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_cronjob_created</parameter><parameter>function</parameter><parameter>count</parameter></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>cronjob</value></tag></tags></item><item><uuid>483fc2c315264ae5963d34a45f80156e</uuid><name>Kubernetes: Deployment count</name><type>DEPENDENT</type><key>kube.deployment.count</key><delay>0</delay><history>7d</history><description>The number of deployments.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_deployment_created</parameter><parameter>function</parameter><parameter>count</parameter></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>deployment</value></tag></tags></item><item><uuid>93126582e30e45b8a70f6e45402e2f54</uuid><name>Kubernetes: Endpoint count</name><type>DEPENDENT</type><key>kube.endpoint.count</key><delay>0</delay><history>7d</history><description>Number of endpoints.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_endpoint_created</parameter><parameter>function</parameter><parameter>count</parameter></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>endpoint</value></tag></tags></item><item><uuid>c08df3a8ae044ae9a331db33bcca7db3</uuid><name>Kubernetes: Job count</name><type>DEPENDENT</type><key>kube.job.count</key><delay>0</delay><history>7d</history><description>Number of jobs(generated by cronjob + job).</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_job_created</parameter><parameter>function</parameter><parameter>count</parameter></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>job</value></tag></tags></item><item><uuid>d731fb05f0284921ab3548ba631f019c</uuid><name>Kubernetes: Get livez</name><type>HTTP_AGENT</type><key>kube.livez</key><history>0</history><trends>0</trends><value_type>TEXT</value_type><preprocessing><step><type>JAVASCRIPT</type><parameters><parameter>var output = [],
    component;

value.split(/\n/).forEach(function (entry) {
    if (component = entry.match(/^\[.+\](.+)\s(\w+)$/)) {
        output.push({
            name: component[1],
            value: component[2]
        });
    }
});

return JSON.stringify(output);</parameter></parameters></step></preprocessing><timeout>10s</timeout><url>{$KUBE.API.URL}{$KUBE.API.LIVEZ.ENDPOINT}?verbose</url><status_codes>200, 403</status_codes><headers><header><name>Authorization</name><value>Bearer {$KUBE.API.TOKEN}</value></header></headers><tags><tag><tag>component</tag><value>raw</value></tag></tags></item><item><uuid>d266edd6dda34e15888b572569a1f301</uuid><name>Kubernetes: Namespace count</name><type>DEPENDENT</type><key>kube.namespace.count</key><delay>0</delay><history>7d</history><description>The number of namespaces.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_namespace_created</parameter><parameter>function</parameter><parameter>count</parameter></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>namespace</value></tag></tags></item><item><uuid>968e1dcaf76645aebd4979b9ad4eca9e</uuid><name>Kubernetes: Node count</name><type>DEPENDENT</type><key>kube.node.count</key><delay>0</delay><history>7d</history><description>The number of nodes.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_node_created</parameter><parameter>function</parameter><parameter>count</parameter></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>node</value></tag></tags></item><item><uuid>aae78585c668466da5d0ab8d8b899828</uuid><name>Kubernetes: Node LLD</name><type>SCRIPT</type><key>kube.node.lld</key><history>0</history><trends>0</trends><value_type>TEXT</value_type><params>var Kube = {
    params: {},

    setParams: function (params) {
        ['api_endpoint', 'token'].forEach(function (field) {
            if (typeof params !== 'object' || typeof params[field] === 'undefined'
                || params[field] === '') {
                throw 'Required param is not set: &quot;' + field + '&quot;.';
            }
        });

        Kube.params = params;
        if (typeof Kube.params.api_endpoint === 'string' &amp;&amp; !Kube.params.api_endpoint.endsWith('/')) {
            Kube.params.api_endpoint += '/';
        }
    },

    request: function (query) {
        var response,
            request = new HttpRequest(),
            url = Kube.params.api_endpoint + query;

        request.addHeader('Content-Type: application/json');
        request.addHeader('Authorization: Bearer ' + Kube.params.token);

        Zabbix.log(4, '[ Kubernetes ] Sending request: ' + url);

        response = request.get(url);

        Zabbix.log(4, '[ Kubernetes ] Received response with status code ' + request.getStatus() + ': ' + response);

        if (request.getStatus() &lt; 200 || request.getStatus() &gt;= 300) {
            throw 'Request failed with status code ' + request.getStatus() + ': ' + response;
        }

        if (response !== null) {
            try {
                response = JSON.parse(response);
            }
            catch (error) {
                throw 'Failed to parse response received from Kubernetes API. Check debug log for more information.';
            }
        }

        return {
            status: request.getStatus(),
            response: response
        };
    },

    getNodes: function () {
        var result = Kube.request('v1/nodes');

        if (typeof result.response !== 'object'
            || typeof result.response.items === 'undefined'
            || result.status != 200) {
            throw 'Cannot get nodes from Kubernetes API. Check debug log for more information.';
        };

        return result.response;
    },
};

try {
    Kube.setParams(JSON.parse(value));

    var nodes = Kube.getNodes(),
        kubeNodes = [];
        api_url = '{$KUBE.API.URL}',
        hostname = api_url.match(/\/\/(.+):/);

    if (typeof hostname[1] === 'undefined') {
          Zabbix.log(4, '[ Kubernetes ] Received incorrect Kubernetes API url: ' + api_url + '. Expected format: &lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;');
          throw 'Cannot get hostname from Kubernetes API url. Check debug log for more information.';
        };
    for (idx in nodes.items) {
        var internalIPs = nodes.items[idx].status.addresses.filter(function (addr) {
            return addr.type === 'InternalIP';
        });

        var internalIP = internalIPs.length &amp;&amp; internalIPs[0].address;

        kubeNodes.push({
            '{#NAME}': nodes.items[idx].metadata.name,
            '{#IP}': internalIP,
            '{#KUBE.KUBELET.URL}': Kube.params.kubelet_scheme + '://' + ((/(\d+.){3}\d+/.test(internalIP)) ? internalIP : '['+internalIP+']')  + ':' + Kube.params.kubelet_port,
            '{#COMPONENT}': 'Kubelet',
            '{#CLUSTER_HOSTNAME}': hostname[1]
        });
    }

    return JSON.stringify(kubeNodes);
}
catch (error) {
    error += (String(error).endsWith('.')) ? '' : '.';
    Zabbix.log(3, '[ Kubernetes ] ERROR: ' + error);
    return JSON.stringify({ error: error });
}</params><description>Generation of data for Kubelet discovery rules.</description><preprocessing><step><type>DISCARD_UNCHANGED_HEARTBEAT</type><parameters><parameter>3h</parameter></parameters></step></preprocessing><timeout>10s</timeout><parameters><parameter><name>token</name><value>{$KUBE.API.TOKEN}</value></parameter><parameter><name>kubelet_scheme</name><value>{$KUBE.KUBELET.SCHEME}</value></parameter><parameter><name>kubelet_port</name><value>{$KUBE.KUBELET.PORT}</value></parameter><parameter><name>api_endpoint</name><value>{$KUBE.API.URL}/api</value></parameter></parameters><tags><tag><tag>component</tag><value>raw</value></tag></tags></item><item><uuid>3a5eaef4e8134dfb9f2935f98a8b88f7</uuid><name>Kubernetes: Get readyz</name><type>HTTP_AGENT</type><key>kube.readyz</key><history>0</history><trends>0</trends><value_type>TEXT</value_type><preprocessing><step><type>JAVASCRIPT</type><parameters><parameter>var output = [],
    component;

value.split(/\n/).forEach(function (entry) {
    if (component = entry.match(/^\[.+\](.+)\s(\w+)$/)) {
        output.push({
            name: component[1],
            value: component[2]
        });
    }
});

return JSON.stringify(output);</parameter></parameters></step></preprocessing><timeout>10s</timeout><url>{$KUBE.API.URL}{$KUBE.API.READYZ.ENDPOINT}?verbose</url><status_codes>200, 403</status_codes><headers><header><name>Authorization</name><value>Bearer {$KUBE.API.TOKEN}</value></header></headers><tags><tag><tag>component</tag><value>raw</value></tag></tags></item><item><uuid>262b0114fed14fec91d50589e97307a7</uuid><name>Kubernetes: Service count</name><type>DEPENDENT</type><key>kube.service.count</key><delay>0</delay><history>7d</history><description>The number of services.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_service_created</parameter><parameter>function</parameter><parameter>count</parameter></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>service</value></tag></tags></item><item><uuid>66e69f9970ce478f8f0ff13f26b248e3</uuid><name>Kubernetes: Get state metrics</name><type>SCRIPT</type><key>kube.state.metrics</key><history>0</history><trends>0</trends><value_type>TEXT</value_type><params>var Kube = {
    params: {},
    metrics_endpoint: undefined,

    setParams: function (params) {
        ['api_endpoint', 'token', 'state_endpoint_name'].forEach(function (field) {
            if (typeof params !== 'object' || typeof params[field] === 'undefined'
                || params[field] === '') {
                throw 'Required param is not set: &quot;' + field + '&quot;.';
            }
        });

          Kube.params = params;
          if (typeof Kube.params.api_endpoint === 'string' &amp;&amp; !Kube.params.api_endpoint.endsWith('/')) {
              Kube.params.api_endpoint += '/';
          }
    },

    apiRequest: function (query) {
        var response,
            request = new HttpRequest(),
            url = Kube.params.api_endpoint + query;

        request.addHeader('Content-Type: application/json');
        request.addHeader('Authorization: Bearer ' + Kube.params.token);

        Zabbix.log(4, '[ Kubernetes ] Sending request: ' + url);

        response = request.get(url);

        Zabbix.log(4, '[ Kubernetes ] Received response with status code ' + request.getStatus() + ': ' + response);

        if (request.getStatus() &lt; 200 || request.getStatus() &gt;= 300) {
            throw 'Request failed with status code ' + request.getStatus() + ': ' + response;
        }

        if (response !== null) {
            try {
                response = JSON.parse(response);
            }
            catch (error) {
                throw 'Failed to parse response received from Kubernetes API. Check debug log for more information.';
            }
        }

        return {
            status: request.getStatus(),
            response: response
        };
    },

    getMetricsEndpoint: function () {
        var result = Kube.apiRequest('v1/endpoints'),
            endpoint = undefined;

        if (typeof result.response !== 'object'
            || typeof result.response.items === 'undefined'
            || result.status != 200) {
            throw 'Cannot get endpoints from Kubernetes API. Check debug log for more information.';
        };

        result.response.items.forEach(function (ep) {
            if (ep.metadata.name === Kube.params.state_endpoint_name &amp;&amp; Array.isArray(ep.subsets)) {
                if (typeof ep.subsets[0].addresses !== 'undefined') {
                    var port, addr
                    ep.subsets.forEach(function(subset){
                        var lp = subset.ports.filter(function (port) {
                            return port.name === 'http';
                        })
                        if (lp.length) {
                            port = lp[0].port
                            addr = subset.addresses[0].ip
                        }
                    })
                    endpoint = {
                        address: addr || ep.subsets[0].addresses[0].ip,
                        port: port || 8080
                    }
                }
            }
        });

        Kube.metrics_endpoint = endpoint;
        return endpoint;
    },

    getStateMetrics: function () {
        if (typeof Kube.metrics_endpoint === 'undefined') {
            throw 'Cannot get kube-state-metrics endpoints from Kubernetes API. Check debug log for more information.';
        }

        var response,
            request = new HttpRequest(),
            url = 'http://' + Kube.metrics_endpoint.address + ':' + Kube.metrics_endpoint.port + '/metrics';

        request.addHeader('Content-Type: application/json');
        request.addHeader('Authorization: Bearer ' + Kube.params.token);

        Zabbix.log(4, '[ Kubernetes ] Sending request: ' + url);

        response = request.get(url);

        Zabbix.log(4, '[ Kubernetes ] Received response with status code ' + request.getStatus() + ': ' + response);

        if (request.getStatus() &lt; 200 || request.getStatus() &gt;= 300) {
            throw 'Request failed with status code ' + request.getStatus() + ': ' + response;
        }

        if (response === null) {
            throw 'failed to get Kubernetes state metrics. Check debug log for more information.';
        }

        return response;

    }
};

try {
    Kube.setParams(JSON.parse(value));

    var metricsEndpoint = Kube.getMetricsEndpoint(),
        stateMetrics = Kube.getStateMetrics();

    return stateMetrics;
}
catch (error) {
    error += (String(error).endsWith('.')) ? '' : '.';
    Zabbix.log(3, '[ Kubernetes ] ERROR: ' + error);
    return JSON.stringify({ error: error });
}</params><description>Collecting Kubernetes metrics from kube-state-metrics.</description><timeout>10s</timeout><parameters><parameter><name>state_endpoint_name</name><value>{$KUBE.STATE.ENDPOINT.NAME}</value></parameter><parameter><name>token</name><value>{$KUBE.API.TOKEN}</value></parameter><parameter><name>api_endpoint</name><value>{$KUBE.API.URL}/api</value></parameter></parameters><tags><tag><tag>component</tag><value>raw</value></tag></tags></item><item><uuid>3940412bea334e139a72b223197582eb</uuid><name>Kubernetes: Statefulset count</name><type>DEPENDENT</type><key>kube.statefulset.count</key><delay>0</delay><history>7d</history><description>The number of statefulsets.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_statefulset_created</parameter><parameter>function</parameter><parameter>count</parameter></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>statefulset</value></tag></tags></item></items><discovery_rules><discovery_rule><uuid>dbfd8959361f4cdd973ed552eb18eb86</uuid><name>API servers discovery</name><type>DEPENDENT</type><key>kube.api_servers.discovery</key><delay>0</delay><host_prototypes><host_prototype><uuid>a67ac5100e6d499088e4c81856f947fc</uuid><host>API {#NAME}</host><name>API {#NAME}</name><group_links><group_link><group><name>Templates/Applications</name></group></group_link></group_links><group_prototypes><group_prototype><name>{#CLUSTER_HOSTNAME}: Kubernetes/Components: {#COMPONENT.API}</name></group_prototype></group_prototypes><templates><template><name>Kubernetes API server by HTTP</name></template></templates><macros><macro><macro>{$KUBE.API.SERVER.URL}</macro><value>{#KUBE.API.SERVER.URL}</value></macro></macros><tags><tag><tag>addr</tag><value>{#IP}</value></tag></tags><custom_interfaces>YES</custom_interfaces><interfaces><interface><ip>{#IP}</ip></interface></interfaces></host_prototype></host_prototypes><master_item><key>kube.control_plane.lld</key></master_item></discovery_rule><discovery_rule><uuid>920b56d5e9234da6b60717763e206736</uuid><name>Component statuses discovery</name><type>DEPENDENT</type><key>kube.componentstatuses.discovery</key><delay>0</delay><item_prototypes><item_prototype><uuid>766e311f05f646d18eaaaa9ea9afa691</uuid><name>Kubernetes: Component [{#NAME}]: Healthy</name><type>DEPENDENT</type><key>kube.componentstatuses.healthy[{#NAME}]</key><delay>0</delay><history>7d</history><trends>0</trends><value_type>CHAR</value_type><description>Cluster component healthy.</description><preprocessing><step><type>JSONPATH</type><parameters><parameter>$.items.[?(@.metadata.name == &quot;{#NAME}&quot;)].conditions[?(@.type == &quot;Healthy&quot;)].status.first()</parameter></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.componentstatuses</key></master_item><tags><tag><tag>component</tag><value>component</value></tag><tag><tag>component</tag><value>{#NAME}</value></tag><tag><tag>status</tag><value>healthy</value></tag></tags><trigger_prototypes><trigger_prototype><uuid>58828a692aa2418ba98c6d66a23f1506</uuid><expression>count(/Kubernetes cluster state by HTTP/kube.componentstatuses.healthy[{#NAME}],#3,,&quot;True&quot;)&lt;2 and length(last(/Kubernetes cluster state by HTTP/kube.componentstatuses.healthy[{#NAME}]))&gt;0</expression><name>Kubernetes: Component [{#NAME}] is unhealthy</name><priority>WARNING</priority><tags><tag><tag>scope</tag><value>availability</value></tag></tags></trigger_prototype></trigger_prototypes></item_prototype></item_prototypes><master_item><key>kube.componentstatuses</key></master_item><preprocessing><step><type>JAVASCRIPT</type><parameters><parameter>var input = JSON.parse(value),
    output = [];

input.items.forEach(function (component) {
    output.push({
        '{#NAME}': component.metadata.name
    });
});

return JSON.stringify(output);</parameter></parameters></step><step><type>DISCARD_UNCHANGED_HEARTBEAT</type><parameters><parameter>3h</parameter></parameters></step></preprocessing></discovery_rule><discovery_rule><uuid>08463c66bce845e7acff0d91785e0982</uuid><name>Controller manager nodes discovery</name><type>DEPENDENT</type><key>kube.controller_manager.discovery</key><delay>0</delay><host_prototypes><host_prototype><uuid>9d529f3924fc4831a62fb1eec79b64d7</uuid><host>Controller manager {#NAME}</host><name>Controller manager {#NAME}</name><group_links><group_link><group><name>Templates/Applications</name></group></group_link></group_links><group_prototypes><group_prototype><name>{#CLUSTER_HOSTNAME}: Kubernetes/Components: {#COMPONENT.CONTROLLER}</name></group_prototype></group_prototypes><templates><template><name>Kubernetes Controller manager by HTTP</name></template></templates><macros><macro><macro>{$KUBE.CONTROLLER.SERVER.URL}</macro><value>{#KUBE.CONTROLLER.SERVER.URL}</value></macro></macros><tags><tag><tag>addr</tag><value>{#IP}</value></tag></tags><custom_interfaces>YES</custom_interfaces><interfaces><interface><ip>{#IP}</ip></interface></interfaces></host_prototype></host_prototypes><master_item><key>kube.control_plane.lld</key></master_item></discovery_rule><discovery_rule><uuid>9bb7532f14dd42c6a532636126e507f9</uuid><name>CronJob discovery</name><type>DEPENDENT</type><key>kube.cronjob.discovery</key><delay>0</delay><filter><evaltype>AND</evaltype><conditions><condition><macro>{#NAMESPACE}</macro><value>{$KUBE.LLD.FILTER.NAMESPACE.MATCHES}</value><formulaid>A</formulaid></condition><condition><macro>{#NAMESPACE}</macro><value>{$KUBE.LLD.FILTER.NAMESPACE.NOT_MATCHES}</value><operator>NOT_MATCHES_REGEX</operator><formulaid>B</formulaid></condition></conditions></filter><lifetime>0</lifetime><item_prototypes><item_prototype><uuid>fd1afcc4646146588fd3c22cf2f7e040</uuid><name>Kubernetes: Namespace [{#NAMESPACE}] CronJob [{#NAME}]: Completion failed</name><type>DEPENDENT</type><key>kube.cronjob.completion.failed[{#NAMESPACE}/{#NAME}]</key><delay>0</delay><history>7d</history><description>Number of job has failed its execution.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_job_failed{namespace=&quot;{#NAMESPACE}&quot;, job_name=~&quot;{#NAME}-*&quot;, condition=&quot;true&quot;}</parameter><parameter>function</parameter><parameter>sum</parameter></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>cronjob</value></tag><tag><tag>cronjob</tag><value>{#NAME}</value></tag><tag><tag>namespace</tag><value>{#NAMESPACE}</value></tag></tags></item_prototype><item_prototype><uuid>5ba1dfd55c784f8597575b38399d5e36</uuid><name>Kubernetes: Namespace [{#NAMESPACE}] CronJob [{#NAME}]: Completion succeeded</name><type>DEPENDENT</type><key>kube.cronjob.completion.succeeded[{#NAMESPACE}/{#NAME}]</key><delay>0</delay><history>7d</history><description>Number of job has completed its execution.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_job_complete{namespace=&quot;{#NAMESPACE}&quot;, job_name=~&quot;{#NAME}-*&quot;, condition=&quot;true&quot;}</parameter><parameter>function</parameter><parameter>sum</parameter></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>cronjob</value></tag><tag><tag>cronjob</tag><value>{#NAME}</value></tag><tag><tag>namespace</tag><value>{#NAMESPACE}</value></tag></tags></item_prototype><item_prototype><uuid>7ae683d5a1ed4f84a09b38863bd263a7</uuid><name>Kubernetes: Namespace [{#NAMESPACE}] CronJob [{#NAME}]: Last schedule</name><type>DEPENDENT</type><key>kube.cronjob.last_schedule_time[{#NAMESPACE}/{#NAME}]</key><delay>0</delay><history>7d</history><trends>0</trends><value_type>CHAR</value_type><description>LastScheduleTime keeps information of when was the last time the job was successfully scheduled.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_cronjob_status_last_schedule_time{namespace=&quot;{#NAMESPACE}&quot;, cronjob=&quot;{#NAME}&quot;}</parameter><parameter>value</parameter><parameter/></parameters><error_handler>DISCARD_VALUE</error_handler></step><step><type>JAVASCRIPT</type><parameters><parameter>return new Date(value * 1000).toString().slice(0,19);</parameter></parameters></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>cronjob</value></tag><tag><tag>cronjob</tag><value>{#NAME}</value></tag><tag><tag>namespace</tag><value>{#NAMESPACE}</value></tag></tags></item_prototype><item_prototype><uuid>8ad7e96b34604a4991698288a7af8027</uuid><name>Kubernetes: Namespace [{#NAMESPACE}] CronJob [{#NAME}]: Next schedule</name><type>DEPENDENT</type><key>kube.cronjob.next_schedule_time[{#NAMESPACE}/{#NAME}]</key><delay>0</delay><history>7d</history><trends>0</trends><value_type>CHAR</value_type><description>Next time the cronjob should be scheduled. The time after lastScheduleTime, or after the cron job's creation time if it's never been scheduled. Use this to determine if the job is delayed.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_cronjob_next_schedule_time{namespace=&quot;{#NAMESPACE}&quot;, cronjob=&quot;{#NAME}&quot;}</parameter><parameter>value</parameter><parameter/></parameters><error_handler>DISCARD_VALUE</error_handler></step><step><type>JAVASCRIPT</type><parameters><parameter>return new Date(value * 1000).toString().slice(0,19);</parameter></parameters></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>cronjob</value></tag><tag><tag>cronjob</tag><value>{#NAME}</value></tag><tag><tag>namespace</tag><value>{#NAMESPACE}</value></tag></tags></item_prototype><item_prototype><uuid>329e8166d1ec42cca7508580efaad366</uuid><name>Kubernetes: Namespace [{#NAMESPACE}] CronJob [{#NAME}]: Suspend</name><type>DEPENDENT</type><key>kube.cronjob.spec_suspend[{#NAMESPACE}/{#NAME}]</key><delay>0</delay><history>7d</history><description>Suspend flag tells the controller to suspend subsequent executions.</description><valuemap><name>CronJob suspend flag</name></valuemap><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_cronjob_spec_suspend{namespace=&quot;{#NAMESPACE}&quot;, cronjob=&quot;{#NAME}&quot;}</parameter><parameter>value</parameter><parameter/></parameters><error_handler>DISCARD_VALUE</error_handler></step><step><type>DISCARD_UNCHANGED_HEARTBEAT</type><parameters><parameter>1h</parameter></parameters></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>cronjob</value></tag><tag><tag>cronjob</tag><value>{#NAME}</value></tag><tag><tag>namespace</tag><value>{#NAMESPACE}</value></tag></tags></item_prototype><item_prototype><uuid>ce13a921915a4232971f2e29102cac64</uuid><name>Kubernetes: Namespace [{#NAMESPACE}] CronJob [{#NAME}]: Active</name><type>DEPENDENT</type><key>kube.cronjob.status_active[{#NAMESPACE}/{#NAME}]</key><delay>0</delay><history>7d</history><description>Active holds pointers to currently running jobs.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_cronjob_status_active{namespace=&quot;{#NAMESPACE}&quot;, cronjob=&quot;{#NAME}&quot;}</parameter><parameter>value</parameter><parameter/></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>cronjob</value></tag><tag><tag>cronjob</tag><value>{#NAME}</value></tag><tag><tag>namespace</tag><value>{#NAMESPACE}</value></tag></tags></item_prototype><item_prototype><uuid>26993138717242079583b1c17d0e8dc8</uuid><name>Kubernetes: Namespace [{#NAMESPACE}] CronJob [{#NAME}]: Failed</name><type>DEPENDENT</type><key>kube.cronjob.status_failed[{#NAMESPACE}/{#NAME}]</key><delay>0</delay><history>7d</history><description>The number of pods which reached Phase Failed and the reason for failure.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_job_status_failed{namespace=&quot;{#NAMESPACE}&quot;, job_name=~&quot;{#NAME}-*&quot;}</parameter><parameter>function</parameter><parameter>sum</parameter></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>cronjob</value></tag><tag><tag>cronjob</tag><value>{#NAME}</value></tag><tag><tag>namespace</tag><value>{#NAMESPACE}</value></tag></tags></item_prototype><item_prototype><uuid>9e5adc642c3a40ab80654542903cd314</uuid><name>Kubernetes: Namespace [{#NAMESPACE}] CronJob [{#NAME}]: Succeeded</name><type>DEPENDENT</type><key>kube.cronjob.status_succeeded[{#NAMESPACE}/{#NAME}]</key><delay>0</delay><history>7d</history><description>The number of pods which reached Phase Succeeded.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_job_status_succeeded{namespace=&quot;{#NAMESPACE}&quot;, job_name=~&quot;{#NAME}-*&quot;}</parameter><parameter>function</parameter><parameter>sum</parameter></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>cronjob</value></tag><tag><tag>cronjob</tag><value>{#NAME}</value></tag><tag><tag>namespace</tag><value>{#NAMESPACE}</value></tag></tags></item_prototype></item_prototypes><master_item><key>kube.state.metrics</key></master_item><preprocessing><step><type>PROMETHEUS_TO_JSON</type><parameters><parameter>kube_cronjob_created</parameter></parameters></step><step><type>JAVASCRIPT</type><parameters><parameter>var input = JSON.parse(value),
    output = [];

input.forEach(function (metric) {
    output.push({
        '{#NAME}': metric.labels.cronjob,
        '{#NAMESPACE}': metric.labels.namespace
    });
});

return JSON.stringify(output);</parameter></parameters></step><step><type>DISCARD_UNCHANGED_HEARTBEAT</type><parameters><parameter>3h</parameter></parameters></step></preprocessing></discovery_rule><discovery_rule><uuid>907dd8e2792e4e1591a99e4cdf65b0f0</uuid><name>Daemonset discovery</name><type>DEPENDENT</type><key>kube.daemonset.discovery</key><delay>0</delay><filter><evaltype>AND</evaltype><conditions><condition><macro>{#NAMESPACE}</macro><value>{$KUBE.LLD.FILTER.NAMESPACE.MATCHES}</value><formulaid>A</formulaid></condition><condition><macro>{#NAMESPACE}</macro><value>{$KUBE.LLD.FILTER.NAMESPACE.NOT_MATCHES}</value><operator>NOT_MATCHES_REGEX</operator><formulaid>B</formulaid></condition></conditions></filter><lifetime>0</lifetime><item_prototypes><item_prototype><uuid>61a295b5e2ec4e1f91984a74d0695c1b</uuid><name>Kubernetes: Namespace [{#NAMESPACE}] Daemonset [{#NAME}]: Desired</name><type>DEPENDENT</type><key>kube.daemonset.desired[{#NAMESPACE}/{#NAME}]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><description>The number of nodes that should be running the daemon pod.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_daemonset_status_desired_number_scheduled{namespace=&quot;{#NAMESPACE}&quot;, daemonset=&quot;{#NAME}&quot;}</parameter><parameter>value</parameter><parameter/></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>daemonset</value></tag><tag><tag>daemonset</tag><value>{#NAME}</value></tag><tag><tag>namespace</tag><value>{#NAMESPACE}</value></tag></tags></item_prototype><item_prototype><uuid>5393cb9b29e442198967cdd2a040d673</uuid><name>Kubernetes: Namespace [{#NAMESPACE}] Daemonset [{#NAME}]: Misscheduled</name><type>DEPENDENT</type><key>kube.daemonset.misscheduled[{#NAMESPACE}/{#NAME}]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><description>The number of nodes running a daemon pod but are not supposed to.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_daemonset_status_number_misscheduled{namespace=&quot;{#NAMESPACE}&quot;, daemonset=&quot;{#NAME}&quot;}</parameter><parameter>value</parameter><parameter/></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>daemonset</value></tag><tag><tag>daemonset</tag><value>{#NAME}</value></tag><tag><tag>namespace</tag><value>{#NAMESPACE}</value></tag></tags></item_prototype><item_prototype><uuid>193ccc0290514c4594193a8bcfd60312</uuid><name>Kubernetes: Namespace [{#NAMESPACE}] Daemonset [{#NAME}]: Ready</name><type>DEPENDENT</type><key>kube.daemonset.ready[{#NAMESPACE}/{#NAME}]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><description>The number of nodes that should be running the daemon pod and have one or more running and ready.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_daemonset_status_number_ready{namespace=&quot;{#NAMESPACE}&quot;, daemonset=&quot;{#NAME}&quot;}</parameter><parameter>value</parameter><parameter/></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>daemonset</value></tag><tag><tag>daemonset</tag><value>{#NAME}</value></tag><tag><tag>namespace</tag><value>{#NAMESPACE}</value></tag></tags></item_prototype><item_prototype><uuid>5727ade78d394d8da1ae46b5d35b5f54</uuid><name>Kubernetes: Namespace [{#NAMESPACE}] Daemonset [{#NAME}]: Scheduled</name><type>DEPENDENT</type><key>kube.daemonset.scheduled[{#NAMESPACE}/{#NAME}]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><description>The number of nodes running at least one daemon pod and are supposed to.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_daemonset_status_current_number_scheduled{namespace=&quot;{#NAMESPACE}&quot;, daemonset=&quot;{#NAME}&quot;}</parameter><parameter>value</parameter><parameter/></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>daemonset</value></tag><tag><tag>daemonset</tag><value>{#NAME}</value></tag><tag><tag>namespace</tag><value>{#NAMESPACE}</value></tag></tags></item_prototype><item_prototype><uuid>d7c1ebe9e42942719dae731a2c440208</uuid><name>Kubernetes: Namespace [{#NAMESPACE}] Daemonset [{#NAME}]: Updated number scheduled</name><type>DEPENDENT</type><key>kube.daemonset.updated[{#NAMESPACE}/{#NAME}]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><description>The total number of nodes that are running updated daemon pod.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_daemonset_status_updated_number_scheduled{namespace=&quot;{#NAMESPACE}&quot;, daemonset=&quot;{#NAME}&quot;}</parameter><parameter>value</parameter><parameter/></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>daemonset</value></tag><tag><tag>daemonset</tag><value>{#NAME}</value></tag><tag><tag>namespace</tag><value>{#NAMESPACE}</value></tag></tags></item_prototype></item_prototypes><master_item><key>kube.state.metrics</key></master_item><preprocessing><step><type>PROMETHEUS_TO_JSON</type><parameters><parameter>kube_daemonset_status_number_ready</parameter></parameters></step><step><type>JAVASCRIPT</type><parameters><parameter>var input = JSON.parse(value),
    output = [];

input.forEach(function (metric) {
    output.push({
        '{#NAME}': metric.labels.daemonset,
        '{#NAMESPACE}': metric.labels.namespace
    });
});

return JSON.stringify(output);</parameter></parameters></step><step><type>DISCARD_UNCHANGED_HEARTBEAT</type><parameters><parameter>3h</parameter></parameters></step></preprocessing></discovery_rule><discovery_rule><uuid>461770e4762f498e86f3f1c931fe27a9</uuid><name>Deployment discovery</name><type>DEPENDENT</type><key>kube.deployment.discovery</key><delay>0</delay><filter><evaltype>AND</evaltype><conditions><condition><macro>{#NAMESPACE}</macro><value>{$KUBE.LLD.FILTER.NAMESPACE.MATCHES}</value><formulaid>A</formulaid></condition><condition><macro>{#NAMESPACE}</macro><value>{$KUBE.LLD.FILTER.NAMESPACE.NOT_MATCHES}</value><operator>NOT_MATCHES_REGEX</operator><formulaid>B</formulaid></condition></conditions></filter><lifetime>0</lifetime><item_prototypes><item_prototype><uuid>943c67dc814e4b06a57fbc4ef609686a</uuid><name>Kubernetes: Namespace [{#NAMESPACE}] Deployment [{#NAME}]: Replicas</name><type>DEPENDENT</type><key>kube.deployment.replicas[{#NAMESPACE}/{#NAME}]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><description>The number of replicas per deployment.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_deployment_status_replicas{namespace=&quot;{#NAMESPACE}&quot;, deployment=&quot;{#NAME}&quot;}</parameter><parameter>value</parameter><parameter/></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>deployment</value></tag><tag><tag>daemonset</tag><value>{#NAME}</value></tag><tag><tag>namespace</tag><value>{#NAMESPACE}</value></tag></tags></item_prototype><item_prototype><uuid>23d730bdea7f444eb5f2ee8bf5987379</uuid><name>Kubernetes: Namespace [{#NAMESPACE}] Deployment [{#NAME}]: Replicas available</name><type>DEPENDENT</type><key>kube.deployment.replicas_available[{#NAMESPACE}/{#NAME}]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><description>The number of available replicas per deployment.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_deployment_status_replicas_available{namespace=&quot;{#NAMESPACE}&quot;, deployment=&quot;{#NAME}&quot;}</parameter><parameter>value</parameter><parameter/></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>deployment</value></tag><tag><tag>daemonset</tag><value>{#NAME}</value></tag><tag><tag>namespace</tag><value>{#NAMESPACE}</value></tag><tag><tag>status</tag><value>available</value></tag></tags></item_prototype><item_prototype><uuid>b79fe110f4d64a94bb78d7f1e9b175e7</uuid><name>Kubernetes: Namespace [{#NAMESPACE}] Deployment [{#NAME}]: Replicas desired</name><type>DEPENDENT</type><key>kube.deployment.replicas_desired[{#NAMESPACE}/{#NAME}]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><description>Number of desired pods for a deployment.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_deployment_spec_replicas{namespace=&quot;{#NAMESPACE}&quot;, deployment=&quot;{#NAME}&quot;}</parameter><parameter>value</parameter><parameter/></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>deployment</value></tag><tag><tag>daemonset</tag><value>{#NAME}</value></tag><tag><tag>namespace</tag><value>{#NAMESPACE}</value></tag></tags></item_prototype><item_prototype><uuid>891537523f98425c8bb1566f984b535a</uuid><name>Kubernetes: Namespace [{#NAMESPACE}] Deployment [{#NAME}]: Replicas unavailable</name><type>DEPENDENT</type><key>kube.deployment.replicas_unavailable[{#NAMESPACE}/{#NAME}]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><description>The number of unavailable replicas per deployment.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_deployment_status_replicas_unavailable{namespace=&quot;{#NAMESPACE}&quot;, deployment=&quot;{#NAME}&quot;}</parameter><parameter>value</parameter><parameter/></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>deployment</value></tag><tag><tag>daemonset</tag><value>{#NAME}</value></tag><tag><tag>namespace</tag><value>{#NAMESPACE}</value></tag><tag><tag>status</tag><value>unavailable</value></tag></tags></item_prototype><item_prototype><uuid>241480bc5e90426abbf5d2792cd846cd</uuid><name>Kubernetes: Namespace [{#NAMESPACE}] Deployment [{#NAME}]: Replicas updated</name><type>DEPENDENT</type><key>kube.deployment.replicas_updated[{#NAMESPACE}/{#NAME}]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><description>The number of updated replicas per deployment.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_deployment_status_replicas_updated{namespace=&quot;{#NAMESPACE}&quot;, deployment=&quot;{#NAME}&quot;}</parameter><parameter>value</parameter><parameter/></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>deployment</value></tag><tag><tag>daemonset</tag><value>{#NAME}</value></tag><tag><tag>namespace</tag><value>{#NAMESPACE}</value></tag><tag><tag>status</tag><value>updated</value></tag></tags></item_prototype><item_prototype><uuid>2651b21facca4bd88929079f4372da37</uuid><name>Kubernetes: Namespace [{#NAMESPACE}] Deployment [{#NAME}]: Rollingupdate max unavailable</name><type>DEPENDENT</type><key>kube.deployment.rollingupdate.max_unavailable[{#NAMESPACE}/{#NAME}]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><description>Maximum number of unavailable replicas during a rolling update of a deployment.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_deployment_spec_strategy_rollingupdate_max_unavailable{namespace=&quot;{#NAMESPACE}&quot;, deployment=&quot;{#NAME}&quot;}</parameter><parameter>value</parameter><parameter/></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>deployment</value></tag><tag><tag>daemonset</tag><value>{#NAME}</value></tag><tag><tag>namespace</tag><value>{#NAMESPACE}</value></tag></tags></item_prototype><item_prototype><uuid>edc5635267b146d2b0a986e5820227ac</uuid><name>Kubernetes: Namespace [{#NAMESPACE}] Deployment [{#NAME}]: Paused</name><type>DEPENDENT</type><key>kube.deployment.spec_paused[{#NAMESPACE}/{#NAME}]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><description>Whether the deployment is paused and will not be processed by the deployment controller.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_deployment_spec_paused{namespace=&quot;{#NAMESPACE}&quot;, deployment=&quot;{#NAME}&quot;}</parameter><parameter>value</parameter><parameter/></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>deployment</value></tag><tag><tag>daemonset</tag><value>{#NAME}</value></tag><tag><tag>namespace</tag><value>{#NAMESPACE}</value></tag></tags></item_prototype></item_prototypes><trigger_prototypes><trigger_prototype><uuid>aa9f828467d84252aecc00dd342b5661</uuid><expression>(last(/Kubernetes cluster state by HTTP/kube.deployment.replicas[{#NAMESPACE}/{#NAME}])-last(/Kubernetes cluster state by HTTP/kube.deployment.replicas_available[{#NAMESPACE}/{#NAME}]))&lt;&gt;0</expression><name>Kubernetes: Namespace [{#NAMESPACE}] Deployment [{#NAME}]: Deployment replicas mismatch</name><priority>WARNING</priority><tags><tag><tag>scope</tag><value>availability</value></tag></tags></trigger_prototype></trigger_prototypes><master_item><key>kube.state.metrics</key></master_item><preprocessing><step><type>PROMETHEUS_TO_JSON</type><parameters><parameter>kube_deployment_spec_paused</parameter></parameters></step><step><type>JAVASCRIPT</type><parameters><parameter>var input = JSON.parse(value),
    output = [];

input.forEach(function (metric) {
    output.push({
        '{#NAME}': metric.labels.deployment,
        '{#NAMESPACE}': metric.labels.namespace
    });
});

return JSON.stringify(output);</parameter></parameters></step><step><type>DISCARD_UNCHANGED_HEARTBEAT</type><parameters><parameter>3h</parameter></parameters></step></preprocessing></discovery_rule><discovery_rule><uuid>671a0dd7f6e54c6893094fa4360d3dd4</uuid><name>Endpoint discovery</name><type>DEPENDENT</type><key>kube.endpoint.discovery</key><delay>0</delay><filter><evaltype>AND</evaltype><conditions><condition><macro>{#NAMESPACE}</macro><value>{$KUBE.LLD.FILTER.NAMESPACE.MATCHES}</value><formulaid>A</formulaid></condition><condition><macro>{#NAMESPACE}</macro><value>{$KUBE.LLD.FILTER.NAMESPACE.NOT_MATCHES}</value><operator>NOT_MATCHES_REGEX</operator><formulaid>B</formulaid></condition></conditions></filter><lifetime>0</lifetime><item_prototypes><item_prototype><uuid>d587eb7186dd425ead2c9554825ba20a</uuid><name>Kubernetes: Namespace [{#NAMESPACE}] Endpoint [{#NAME}]: Address available</name><type>DEPENDENT</type><key>kube.endpoint.address_available[{#NAMESPACE}/{#NAME}]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><description>Number of addresses available in endpoint.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_endpoint_address_available{namespace=&quot;{#NAMESPACE}&quot;, endpoint=&quot;{#NAME}&quot;}</parameter><parameter>value</parameter><parameter/></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>endpoint</value></tag><tag><tag>endpoint</tag><value>{#NAME}</value></tag><tag><tag>namespace</tag><value>{#NAMESPACE}</value></tag><tag><tag>status</tag><value>available</value></tag></tags></item_prototype><item_prototype><uuid>91fc21c37e144890858137f7f5c38135</uuid><name>Kubernetes: Namespace [{#NAMESPACE}] Endpoint [{#NAME}]: Address not ready</name><type>DEPENDENT</type><key>kube.endpoint.address_not_ready[{#NAMESPACE}/{#NAME}]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><description>Number of addresses not ready in endpoint.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_endpoint_address_not_ready{namespace=&quot;{#NAMESPACE}&quot;, endpoint=&quot;{#NAME}&quot;}</parameter><parameter>value</parameter><parameter/></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>endpoint</value></tag><tag><tag>endpoint</tag><value>{#NAME}</value></tag><tag><tag>namespace</tag><value>{#NAMESPACE}</value></tag><tag><tag>status</tag><value>not-ready</value></tag></tags></item_prototype><item_prototype><uuid>f6c2a426e0154c34b2bcb98eeeb88a0d</uuid><name>Kubernetes: Namespace [{#NAMESPACE}] Endpoint [{#NAME}]: Age</name><type>DEPENDENT</type><key>kube.endpoint.age[{#NAMESPACE}/{#NAME}]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><units>s</units><description>Endpoint age (number of seconds since creation).</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_endpoint_created{namespace=&quot;{#NAMESPACE}&quot;, endpoint=&quot;{#NAME}&quot;}</parameter><parameter>value</parameter><parameter/></parameters><error_handler>DISCARD_VALUE</error_handler></step><step><type>JAVASCRIPT</type><parameters><parameter>return (Math.floor(Date.now()/1000)-Number(value))</parameter></parameters></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>endpoint</value></tag><tag><tag>endpoint</tag><value>{#NAME}</value></tag><tag><tag>namespace</tag><value>{#NAMESPACE}</value></tag></tags></item_prototype></item_prototypes><master_item><key>kube.state.metrics</key></master_item><preprocessing><step><type>PROMETHEUS_TO_JSON</type><parameters><parameter>kube_endpoint_created</parameter></parameters></step><step><type>JAVASCRIPT</type><parameters><parameter>var input = JSON.parse(value),
    output = [];

input.forEach(function (metric) {
    output.push({
        '{#NAME}': metric.labels.endpoint,
        '{#NAMESPACE}': metric.labels.namespace
    });
});

return JSON.stringify(output);</parameter></parameters></step><step><type>DISCARD_UNCHANGED_HEARTBEAT</type><parameters><parameter>3h</parameter></parameters></step></preprocessing></discovery_rule><discovery_rule><uuid>bc6897c5abe246fdb1ba72c1e71cdb81</uuid><name>Job discovery</name><type>DEPENDENT</type><key>kube.job.discovery</key><delay>0</delay><filter><evaltype>AND</evaltype><conditions><condition><macro>{#NAMESPACE}</macro><value>{$KUBE.LLD.FILTER.NAMESPACE.MATCHES}</value><formulaid>A</formulaid></condition><condition><macro>{#NAMESPACE}</macro><value>{$KUBE.LLD.FILTER.NAMESPACE.NOT_MATCHES}</value><operator>NOT_MATCHES_REGEX</operator><formulaid>B</formulaid></condition></conditions></filter><lifetime>0</lifetime><item_prototypes><item_prototype><uuid>b1fad48e204e4bf9a03c79baa0f58963</uuid><name>Kubernetes: Namespace [{#NAMESPACE}] Job [{#NAME}]: Completion failed</name><type>DEPENDENT</type><key>kube.job.completion.failed[{#NAMESPACE}/{#NAME}]</key><delay>0</delay><history>7d</history><description>Number of job has failed its execution.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_job_failed{namespace=&quot;{#NAMESPACE}&quot;, job_name=&quot;{#NAME}&quot;, condition=&quot;true&quot;}</parameter><parameter>value</parameter><parameter/></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>job</value></tag><tag><tag>job</tag><value>{#NAME}</value></tag><tag><tag>namespace</tag><value>{#NAMESPACE}</value></tag></tags></item_prototype><item_prototype><uuid>51d3653b2c7543dba04339ded6ff65dd</uuid><name>Kubernetes: Namespace [{#NAMESPACE}] Job [{#NAME}]: Completion succeeded</name><type>DEPENDENT</type><key>kube.job.completion.succeeded[{#NAMESPACE}/{#NAME}]</key><delay>0</delay><history>7d</history><description>Number of job has completed its execution.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_job_complete{namespace=&quot;{#NAMESPACE}&quot;, job_name=&quot;{#NAME}&quot;, condition=&quot;true&quot;}</parameter><parameter>value</parameter><parameter/></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>job</value></tag><tag><tag>job</tag><value>{#NAME}</value></tag><tag><tag>namespace</tag><value>{#NAMESPACE}</value></tag></tags></item_prototype><item_prototype><uuid>f175e0bd1f6b41a2b62e69df40b3fc07</uuid><name>Kubernetes: Namespace [{#NAMESPACE}] Job [{#NAME}]: Failed</name><type>DEPENDENT</type><key>kube.job.status_failed[{#NAMESPACE}/{#NAME}]</key><delay>0</delay><history>7d</history><description>The number of pods which reached Phase Failed and the reason for failure.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_job_status_failed{namespace=&quot;{#NAMESPACE}&quot;, job_name=&quot;{#NAME}&quot;}</parameter><parameter>value</parameter><parameter/></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>job</value></tag><tag><tag>job</tag><value>{#NAME}</value></tag><tag><tag>namespace</tag><value>{#NAMESPACE}</value></tag></tags></item_prototype><item_prototype><uuid>b909868367d5481d982d33d5248167ab</uuid><name>Kubernetes: Namespace [{#NAMESPACE}] Job [{#NAME}]: Succeeded</name><type>DEPENDENT</type><key>kube.job.status_succeeded[{#NAMESPACE}/{#NAME}]</key><delay>0</delay><history>7d</history><description>The number of pods which reached Phase Succeeded.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_job_status_succeeded{namespace=&quot;{#NAMESPACE}&quot;, job_name=&quot;{#NAME}&quot;}</parameter><parameter>value</parameter><parameter/></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>job</value></tag><tag><tag>job</tag><value>{#NAME}</value></tag><tag><tag>namespace</tag><value>{#NAMESPACE}</value></tag></tags></item_prototype></item_prototypes><master_item><key>kube.state.metrics</key></master_item><preprocessing><step><type>PROMETHEUS_TO_JSON</type><parameters><parameter>kube_job_owner{owner_is_controller=&quot;&lt;none&gt;&quot;}</parameter></parameters></step><step><type>JAVASCRIPT</type><parameters><parameter>var input = JSON.parse(value),
    output = [];

input.forEach(function (metric) {
    output.push({
        '{#NAME}': metric.labels.job_name,
        '{#NAMESPACE}': metric.labels.namespace
    });
});

return JSON.stringify(output);</parameter></parameters></step><step><type>DISCARD_UNCHANGED_HEARTBEAT</type><parameters><parameter>3h</parameter></parameters></step></preprocessing></discovery_rule><discovery_rule><uuid>11ca82627209443a96693e443d6391c1</uuid><name>Kubelet discovery</name><type>DEPENDENT</type><key>kube.kubelet.discovery</key><delay>0</delay><filter><evaltype>AND</evaltype><conditions><condition><macro>{#NAME}</macro><value>{$KUBE.LLD.FILTER.WORKER_NODE.MATCHES}</value><formulaid>A</formulaid></condition><condition><macro>{#NAME}</macro><value>{$KUBE.LLD.FILTER.WORKER_NODE.NOT_MATCHES}</value><operator>NOT_MATCHES_REGEX</operator><formulaid>B</formulaid></condition></conditions></filter><host_prototypes><host_prototype><uuid>c1c4807f378a47dfa59e9bbc8e43f5e2</uuid><host>Kubelet {#NAME}</host><name>Kubelet {#NAME}</name><group_links><group_link><group><name>Templates/Applications</name></group></group_link></group_links><group_prototypes><group_prototype><name>{#CLUSTER_HOSTNAME}: Kubernetes/Components: {#COMPONENT}</name></group_prototype></group_prototypes><templates><template><name>Kubernetes Kubelet by HTTP</name></template></templates><macros><macro><macro>{$KUBE.KUBELET.URL}</macro><value>{#KUBE.KUBELET.URL}</value></macro></macros><tags><tag><tag>addr</tag><value>{#IP}</value></tag></tags><custom_interfaces>YES</custom_interfaces><interfaces><interface><ip>{#IP}</ip></interface></interfaces></host_prototype></host_prototypes><master_item><key>kube.node.lld</key></master_item></discovery_rule><discovery_rule><uuid>438e963e02a749b5a2cc487b9fd5db05</uuid><name>Livez discovery</name><type>DEPENDENT</type><key>kube.livez.discovery</key><delay>0</delay><item_prototypes><item_prototype><uuid>93548d985c1542a891bfc74f2d42d59a</uuid><name>Kubernetes: Livez [{#NAME}]: Healthcheck</name><type>DEPENDENT</type><key>kube.livez.healthcheck[{#NAME}]</key><delay>0</delay><history>7d</history><trends>0</trends><value_type>CHAR</value_type><description>Result of livez healthcheck for component.</description><preprocessing><step><type>JSONPATH</type><parameters><parameter>$.[?(@.name == &quot;{#NAME}&quot;)].value.first()</parameter></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.livez</key></master_item><tags><tag><tag>component</tag><value>livez</value></tag><tag><tag>component</tag><value>{#NAME}</value></tag></tags><trigger_prototypes><trigger_prototype><uuid>9fcb23d29ac3481a8613515cc2cccfcf</uuid><expression>count(/Kubernetes cluster state by HTTP/kube.livez.healthcheck[{#NAME}],#3,,&quot;ok&quot;)&lt;2 and length(last(/Kubernetes cluster state by HTTP/kube.livez.healthcheck[{#NAME}]))&gt;0</expression><name>Kubernetes: Livez [{#NAME}] is unhealthy</name><priority>WARNING</priority><tags><tag><tag>scope</tag><value>availability</value></tag></tags></trigger_prototype></trigger_prototypes></item_prototype></item_prototypes><master_item><key>kube.livez</key></master_item><preprocessing><step><type>JAVASCRIPT</type><parameters><parameter>var input = JSON.parse(value),
    output = [];

input.forEach(function (component) {
    output.push({
        '{#NAME}': component.name
    });
});

return JSON.stringify(output);</parameter></parameters></step><step><type>DISCARD_UNCHANGED_HEARTBEAT</type><parameters><parameter>3h</parameter></parameters></step></preprocessing></discovery_rule><discovery_rule><uuid>9d161120d2be48d1abb6e56107057874</uuid><name>Node discovery</name><type>DEPENDENT</type><key>kube.node.discovery</key><delay>0</delay><filter><evaltype>AND</evaltype><conditions><condition><macro>{#NAME}</macro><value>{$KUBE.LLD.FILTER.NODE.MATCHES}</value><formulaid>A</formulaid></condition><condition><macro>{#NAME}</macro><value>{$KUBE.LLD.FILTER.NODE.NOT_MATCHES}</value><operator>NOT_MATCHES_REGEX</operator><formulaid>B</formulaid></condition></conditions></filter><item_prototypes><item_prototype><uuid>4f994219cbe94dfe8d96af1ad5018212</uuid><name>Kubernetes: Node [{#NAME}]: CPU allocatable</name><type>DEPENDENT</type><key>kube.node.cpu_allocatable[{#NAME}]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><units>cpu</units><description>The CPU resources of a node that are available for scheduling.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_node_status_allocatable{node=&quot;{#NAME}&quot;, resource=&quot;cpu&quot;}</parameter><parameter>value</parameter><parameter/></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>cpu</value></tag><tag><tag>node</tag><value>{#NAME}</value></tag><tag><tag>status</tag><value>allocatable</value></tag></tags></item_prototype><item_prototype><uuid>5d3ad3e1b2a547aea65b557ff2765ef7</uuid><name>Kubernetes: Node [{#NAME}]: CPU capacity</name><type>DEPENDENT</type><key>kube.node.cpu_capacity[{#NAME}]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><units>cpu</units><description>The capacity for CPU resources of a node.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_node_status_capacity{node=&quot;{#NAME}&quot;, resource=&quot;cpu&quot;}</parameter><parameter>value</parameter><parameter/></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>cpu</value></tag><tag><tag>node</tag><value>{#NAME}</value></tag><tag><tag>status</tag><value>capacity</value></tag></tags></item_prototype><item_prototype><uuid>49440553854441f39ecbcf7052d83e51</uuid><name>Kubernetes: Node [{#NAME}]: Ephemeral storage allocatable</name><type>DEPENDENT</type><key>kube.node.ephemeral_storage_allocatable[{#NAME}]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><units>B</units><description>The allocatable ephemeral-storage of a node that is available for scheduling.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_node_status_allocatable{node=&quot;{#NAME}&quot;, resource=&quot;ephemeral_storage&quot;}</parameter><parameter>value</parameter><parameter/></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>ephemeral-storage</value></tag><tag><tag>node</tag><value>{#NAME}</value></tag><tag><tag>status</tag><value>capacity</value></tag></tags></item_prototype><item_prototype><uuid>2831a4b1bc1549198203f3e894f07a1f</uuid><name>Kubernetes: Node [{#NAME}]: Ephemeral storage capacity</name><type>DEPENDENT</type><key>kube.node.ephemeral_storage_capacity[{#NAME}]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><units>B</units><description>The ephemeral-storage capacity of a node.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_node_status_capacity{node=&quot;{#NAME}&quot;, resource=&quot;ephemeral_storage&quot;}</parameter><parameter>value</parameter><parameter/></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>ephemeral-storage</value></tag><tag><tag>node</tag><value>{#NAME}</value></tag><tag><tag>status</tag><value>capacity</value></tag></tags></item_prototype><item_prototype><uuid>0247f7ba014443a0b13a4fdd3e191062</uuid><name>Kubernetes: Node [{#NAME}]: Memory allocatable</name><type>DEPENDENT</type><key>kube.node.memory_allocatable[{#NAME}]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><units>B</units><description>The Memory resources of a node that are available for scheduling.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_node_status_allocatable{node=&quot;{#NAME}&quot;, resource=&quot;memory&quot;}</parameter><parameter>value</parameter><parameter/></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>memory</value></tag><tag><tag>node</tag><value>{#NAME}</value></tag><tag><tag>status</tag><value>allocatable</value></tag></tags></item_prototype><item_prototype><uuid>3336028952b14e2ab3dae55659156ea3</uuid><name>Kubernetes: Node [{#NAME}]: Memory capacity</name><type>DEPENDENT</type><key>kube.node.memory_capacity[{#NAME}]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><units>B</units><description>The capacity for Memory resources of a node.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_node_status_capacity{node=&quot;{#NAME}&quot;, resource=&quot;memory&quot;}</parameter><parameter>value</parameter><parameter/></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>memory</value></tag><tag><tag>node</tag><value>{#NAME}</value></tag><tag><tag>status</tag><value>capacity</value></tag></tags></item_prototype><item_prototype><uuid>049eb92c52a24c9887d7120f2a7e106c</uuid><name>Kubernetes: Node [{#NAME}]: Pods allocatable</name><type>DEPENDENT</type><key>kube.node.pods_allocatable[{#NAME}]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><description>The Pods resources of a node that are available for scheduling.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_node_status_allocatable{node=&quot;{#NAME}&quot;, resource=&quot;pods&quot;}</parameter><parameter>value</parameter><parameter/></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>pods</value></tag><tag><tag>node</tag><value>{#NAME}</value></tag><tag><tag>status</tag><value>allocatable</value></tag></tags></item_prototype><item_prototype><uuid>163edc95ec7d41f29099b94409916d82</uuid><name>Kubernetes: Node [{#NAME}]: Pods capacity</name><type>DEPENDENT</type><key>kube.node.pods_capacity[{#NAME}]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><description>The capacity for Pods resources of a node.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_node_status_capacity{node=&quot;{#NAME}&quot;, resource=&quot;pods&quot;}</parameter><parameter>value</parameter><parameter/></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>pods</value></tag><tag><tag>node</tag><value>{#NAME}</value></tag><tag><tag>status</tag><value>capacity</value></tag></tags></item_prototype></item_prototypes><master_item><key>kube.state.metrics</key></master_item><preprocessing><step><type>PROMETHEUS_TO_JSON</type><parameters><parameter>kube_node_info</parameter></parameters></step><step><type>JAVASCRIPT</type><parameters><parameter>var input = JSON.parse(value),
    output = [];

input.forEach(function (metric) {
    output.push({
        '{#NAME}': metric.labels.node
    });
});

return JSON.stringify(output);</parameter></parameters></step><step><type>DISCARD_UNCHANGED_HEARTBEAT</type><parameters><parameter>3h</parameter></parameters></step></preprocessing></discovery_rule><discovery_rule><uuid>a7bf79185bab4eb8891e5a154424a96d</uuid><name>PodDisruptionBudget discovery</name><type>DEPENDENT</type><key>kube.pdb.discovery</key><delay>0</delay><filter><evaltype>AND</evaltype><conditions><condition><macro>{#NAMESPACE}</macro><value>{$KUBE.LLD.FILTER.NAMESPACE.MATCHES}</value><formulaid>A</formulaid></condition><condition><macro>{#NAMESPACE}</macro><value>{$KUBE.LLD.FILTER.NAMESPACE.NOT_MATCHES}</value><operator>NOT_MATCHES_REGEX</operator><formulaid>B</formulaid></condition></conditions></filter><lifetime>0</lifetime><item_prototypes><item_prototype><uuid>3eef1fb3311e429fa3043c9e4d88335f</uuid><name>Kubernetes: Namespace [{#NAMESPACE}] PodDisruptionBudget [{#NAME}]: Disruptions allowed</name><type>DEPENDENT</type><key>kube.pdb.disruptions_allowed[{#NAMESPACE}/{#NAME}]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><description>Number of pod disruptions that are allowed.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_poddisruptionbudget_status_pod_disruptions_allowed{namespace=&quot;{#NAMESPACE}&quot;, poddisruptionbudget=&quot;{#NAME}&quot;}</parameter><parameter>value</parameter><parameter/></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>pdb</value></tag><tag><tag>namespace</tag><value>{#NAMESPACE}</value></tag><tag><tag>pdb</tag><value>{#NAME}</value></tag></tags></item_prototype><item_prototype><uuid>a303e07be68c40bdb7d996696af53c98</uuid><name>Kubernetes: Namespace [{#NAMESPACE}] PodDisruptionBudget [{#NAME}]: Pods desired</name><type>DEPENDENT</type><key>kube.pdb.pods_desired[{#NAMESPACE}/{#NAME}]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><description>Minimum desired number of healthy pods.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_poddisruptionbudget_status_desired_healthy{namespace=&quot;{#NAMESPACE}&quot;, poddisruptionbudget=&quot;{#NAME}&quot;}</parameter><parameter>value</parameter><parameter/></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>pdb</value></tag><tag><tag>namespace</tag><value>{#NAMESPACE}</value></tag><tag><tag>pdb</tag><value>{#NAME}</value></tag></tags></item_prototype><item_prototype><uuid>f2a82d6de52446f594a6554137508604</uuid><name>Kubernetes: Namespace [{#NAMESPACE}] PodDisruptionBudget [{#NAME}]: Pods healthy</name><type>DEPENDENT</type><key>kube.pdb.pods_healthy[{#NAMESPACE}/{#NAME}]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><description>Current number of healthy pods.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_poddisruptionbudget_status_current_healthy{namespace=&quot;{#NAMESPACE}&quot;, poddisruptionbudget=&quot;{#NAME}&quot;}</parameter><parameter>value</parameter><parameter/></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>pdb</value></tag><tag><tag>namespace</tag><value>{#NAMESPACE}</value></tag><tag><tag>pdb</tag><value>{#NAME}</value></tag></tags></item_prototype><item_prototype><uuid>2c15033188ab4062a432f30c3320677f</uuid><name>Kubernetes: Namespace [{#NAMESPACE}] PodDisruptionBudget [{#NAME}]: Pods total</name><type>DEPENDENT</type><key>kube.pdb.pods_total[{#NAMESPACE}/{#NAME}]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><description>Total number of pods counted by this disruption budget.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_poddisruptionbudget_status_expected_pods{namespace=&quot;{#NAMESPACE}&quot;, poddisruptionbudget=&quot;{#NAME}&quot;}</parameter><parameter>value</parameter><parameter/></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>pdb</value></tag><tag><tag>namespace</tag><value>{#NAMESPACE}</value></tag><tag><tag>pdb</tag><value>{#NAME}</value></tag></tags></item_prototype></item_prototypes><master_item><key>kube.state.metrics</key></master_item><preprocessing><step><type>PROMETHEUS_TO_JSON</type><parameters><parameter>kube_poddisruptionbudget_created</parameter></parameters></step><step><type>JAVASCRIPT</type><parameters><parameter>var input = JSON.parse(value),
    output = [];

input.forEach(function (metric) {
    output.push({
        '{#NAME}': metric.labels.poddisruptionbudget,
        '{#NAMESPACE}': metric.labels.namespace
    });
});

return JSON.stringify(output);</parameter></parameters></step><step><type>DISCARD_UNCHANGED_HEARTBEAT</type><parameters><parameter>3h</parameter></parameters></step></preprocessing></discovery_rule><discovery_rule><uuid>d88889ab64804c4389d3755ea49b80d6</uuid><name>Pod discovery</name><type>DEPENDENT</type><key>kube.pod.discovery</key><delay>0</delay><filter><evaltype>AND</evaltype><conditions><condition><macro>{#NAMESPACE}</macro><value>{$KUBE.LLD.FILTER.NAMESPACE.MATCHES}</value><formulaid>A</formulaid></condition><condition><macro>{#NAMESPACE}</macro><value>{$KUBE.LLD.FILTER.NAMESPACE.NOT_MATCHES}</value><operator>NOT_MATCHES_REGEX</operator><formulaid>B</formulaid></condition></conditions></filter><lifetime>0</lifetime><item_prototypes><item_prototype><uuid>3a145b38d57f4164a7a9ef0dd15c530a</uuid><name>Kubernetes: Namespace [{#NAMESPACE}] Pod [{#NAME}]: Containers CPU limits</name><type>DEPENDENT</type><key>kube.pod.containers.limits.cpu[{#NAMESPACE}/{#NAME}]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><description>The limit on CPU cores to be used by a container.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_pod_container_resource_limits{pod=&quot;{#NAME}&quot;, resource=&quot;cpu&quot;}</parameter><parameter>function</parameter><parameter>sum</parameter></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>pod</value></tag><tag><tag>namespace</tag><value>{#NAMESPACE}</value></tag><tag><tag>pod</tag><value>{#NAME}</value></tag><tag><tag>resource</tag><value>cpu</value></tag></tags></item_prototype><item_prototype><uuid>e1dd38e6fb484610891aef057a58daf0</uuid><name>Kubernetes: Namespace [{#NAMESPACE}] Pod [{#NAME}]: Containers memory limits</name><type>DEPENDENT</type><key>kube.pod.containers.limits.memory[{#NAMESPACE}/{#NAME}]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><units>B</units><description>The limit on memory to be used by a container.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_pod_container_resource_limits{pod=&quot;{#NAME}&quot;, resource=&quot;memory&quot;}</parameter><parameter>function</parameter><parameter>sum</parameter></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>pod</value></tag><tag><tag>namespace</tag><value>{#NAMESPACE}</value></tag><tag><tag>pod</tag><value>{#NAME}</value></tag><tag><tag>resource</tag><value>memory</value></tag></tags></item_prototype><item_prototype><uuid>8465ea15f3974476924cb66df5a63e0c</uuid><name>Kubernetes: Namespace [{#NAMESPACE}] Pod [{#NAME}]: Containers CPU requests</name><type>DEPENDENT</type><key>kube.pod.containers.requests.cpu[{#NAMESPACE}/{#NAME}]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><description>The number of requested cpu cores by a container.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_pod_container_resource_requests{pod=&quot;{#NAME}&quot;, resource=&quot;cpu&quot;}</parameter><parameter>function</parameter><parameter>sum</parameter></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>pod</value></tag><tag><tag>namespace</tag><value>{#NAMESPACE}</value></tag><tag><tag>pod</tag><value>{#NAME}</value></tag><tag><tag>resource</tag><value>cpu</value></tag></tags></item_prototype><item_prototype><uuid>27379c192d0841a5adb2c2e4ae937263</uuid><name>Kubernetes: Namespace [{#NAMESPACE}] Pod [{#NAME}]: Containers memory requests</name><type>DEPENDENT</type><key>kube.pod.containers.requests.memory[{#NAMESPACE}/{#NAME}]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><units>B</units><description>The number of requested memory bytes by a container.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_pod_container_resource_requests{pod=&quot;{#NAME}&quot;, resource=&quot;memory&quot;}</parameter><parameter>function</parameter><parameter>sum</parameter></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>pod</value></tag><tag><tag>namespace</tag><value>{#NAMESPACE}</value></tag><tag><tag>pod</tag><value>{#NAME}</value></tag><tag><tag>resource</tag><value>memory</value></tag></tags></item_prototype><item_prototype><uuid>1719bf9d1a1c443dbddcefb91483a77c</uuid><name>Kubernetes: Namespace [{#NAMESPACE}] Pod [{#NAME}]: Containers ready</name><type>DEPENDENT</type><key>kube.pod.containers_ready[{#NAMESPACE}/{#NAME}]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><description>Describes whether the containers readiness check succeeded.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_pod_container_status_ready{pod=&quot;{#NAME}&quot;}</parameter><parameter>function</parameter><parameter>sum</parameter></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>pod</value></tag><tag><tag>namespace</tag><value>{#NAMESPACE}</value></tag><tag><tag>pod</tag><value>{#NAME}</value></tag><tag><tag>status</tag><value>ready</value></tag></tags></item_prototype><item_prototype><uuid>fbc8f3a91ec9429ca4c6d70c07480dcc</uuid><name>Kubernetes: Namespace [{#NAMESPACE}] Pod [{#NAME}]: Containers restarts</name><type>DEPENDENT</type><key>kube.pod.containers_restarts[{#NAMESPACE}/{#NAME}]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><description>The number of container restarts.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_pod_container_status_restarts_total{pod=&quot;{#NAME}&quot;}</parameter><parameter>function</parameter><parameter>sum</parameter></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>pod</value></tag><tag><tag>namespace</tag><value>{#NAMESPACE}</value></tag><tag><tag>pod</tag><value>{#NAME}</value></tag><tag><tag>status</tag><value>restarts</value></tag></tags><trigger_prototypes><trigger_prototype><uuid>4656457043d04f4a9b829222ad071d22</uuid><expression>(last(/Kubernetes cluster state by HTTP/kube.pod.containers_restarts[{#NAMESPACE}/{#NAME}])-min(/Kubernetes cluster state by HTTP/kube.pod.containers_restarts[{#NAMESPACE}/{#NAME}],#3))&gt;2</expression><name>Kubernetes: Namespace [{#NAMESPACE}] Pod [{#NAME}]: Pod is crash looping</name><priority>WARNING</priority><tags><tag><tag>scope</tag><value>availability</value></tag></tags></trigger_prototype></trigger_prototypes></item_prototype><item_prototype><uuid>b96149f7a44d4a49903421fbc38c0101</uuid><name>Kubernetes: Namespace [{#NAMESPACE}] Pod [{#NAME}]: Containers running</name><type>DEPENDENT</type><key>kube.pod.containers_running[{#NAMESPACE}/{#NAME}]</key><delay>0</delay><history>7d</history><description>Describes whether the container is currently in running state.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_pod_container_status_running{pod=&quot;{#NAME}&quot;}</parameter><parameter>function</parameter><parameter>sum</parameter></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>pod</value></tag><tag><tag>namespace</tag><value>{#NAMESPACE}</value></tag><tag><tag>pod</tag><value>{#NAME}</value></tag><tag><tag>status</tag><value>running</value></tag></tags></item_prototype><item_prototype><uuid>50785c1c96894866973ebf8491e3c320</uuid><name>Kubernetes: Namespace [{#NAMESPACE}] Pod [{#NAME}]: Containers terminated</name><type>DEPENDENT</type><key>kube.pod.containers_terminated[{#NAMESPACE}/{#NAME}]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><description>Describes whether the container is currently in terminated state.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_pod_container_status_terminated{pod=&quot;{#NAME}&quot;}</parameter><parameter>function</parameter><parameter>sum</parameter></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>pod</value></tag><tag><tag>namespace</tag><value>{#NAMESPACE}</value></tag><tag><tag>pod</tag><value>{#NAME}</value></tag><tag><tag>status</tag><value>terminated</value></tag></tags></item_prototype><item_prototype><uuid>01d80d5f171f4af2b3b1da70679e87ba</uuid><name>Kubernetes: Namespace [{#NAMESPACE}] Pod [{#NAME}]: Containers waiting</name><type>DEPENDENT</type><key>kube.pod.containers_waiting[{#NAMESPACE}/{#NAME}]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><description>Describes whether the container is currently in waiting state.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_pod_container_status_waiting{pod=&quot;{#NAME}&quot;}</parameter><parameter>function</parameter><parameter>sum</parameter></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>pod</value></tag><tag><tag>namespace</tag><value>{#NAMESPACE}</value></tag><tag><tag>pod</tag><value>{#NAME}</value></tag><tag><tag>status</tag><value>waiting</value></tag></tags></item_prototype><item_prototype><uuid>dedbaa4308624b6b982a7e6b62f92d3f</uuid><name>Kubernetes: Namespace [{#NAMESPACE}] Pod [{#NAME}] Phase: Failed</name><type>DEPENDENT</type><key>kube.pod.phase.failed[{#NAMESPACE}/{#NAME}]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><description>Pod is in failed state.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_pod_status_phase{pod=&quot;{#NAME}&quot;, phase=&quot;Failed&quot;}</parameter><parameter>value</parameter><parameter/></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>pod</value></tag><tag><tag>namespace</tag><value>{#NAMESPACE}</value></tag><tag><tag>phase</tag><value>failed</value></tag><tag><tag>pod</tag><value>{#NAME}</value></tag></tags></item_prototype><item_prototype><uuid>fa3759bb7873453b9842f3e459403163</uuid><name>Kubernetes: Namespace [{#NAMESPACE}] Pod [{#NAME}] Phase: Pending</name><type>DEPENDENT</type><key>kube.pod.phase.pending[{#NAMESPACE}/{#NAME}]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><description>Pod is in pending state.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_pod_status_phase{pod=&quot;{#NAME}&quot;, phase=&quot;Pending&quot;}</parameter><parameter>value</parameter><parameter/></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>pod</value></tag><tag><tag>namespace</tag><value>{#NAMESPACE}</value></tag><tag><tag>phase</tag><value>pending</value></tag><tag><tag>pod</tag><value>{#NAME}</value></tag></tags></item_prototype><item_prototype><uuid>59168479f1e246bf8da46606f3ce2a5e</uuid><name>Kubernetes: Namespace [{#NAMESPACE}] Pod [{#NAME}] Phase: Running</name><type>DEPENDENT</type><key>kube.pod.phase.running[{#NAMESPACE}/{#NAME}]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><description>Pod is in unknown state.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_pod_status_phase{pod=&quot;{#NAME}&quot;, phase=&quot;Running&quot;}</parameter><parameter>value</parameter><parameter/></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>pod</value></tag><tag><tag>namespace</tag><value>{#NAMESPACE}</value></tag><tag><tag>phase</tag><value>running</value></tag><tag><tag>pod</tag><value>{#NAME}</value></tag></tags></item_prototype><item_prototype><uuid>8a9451a6466f4c64b31377d850841578</uuid><name>Kubernetes: Namespace [{#NAMESPACE}] Pod [{#NAME}] Phase: Succeeded</name><type>DEPENDENT</type><key>kube.pod.phase.succeeded[{#NAMESPACE}/{#NAME}]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><description>Pod is in succeeded state.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_pod_status_phase{pod=&quot;{#NAME}&quot;, phase=&quot;Succeeded&quot;}</parameter><parameter>value</parameter><parameter/></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>pod</value></tag><tag><tag>namespace</tag><value>{#NAMESPACE}</value></tag><tag><tag>phase</tag><value>succeeded</value></tag><tag><tag>pod</tag><value>{#NAME}</value></tag></tags></item_prototype><item_prototype><uuid>9303dab482754a7b991b3ba4afef96e7</uuid><name>Kubernetes: Namespace [{#NAMESPACE}] Pod [{#NAME}] Phase: Unknown</name><type>DEPENDENT</type><key>kube.pod.phase.unknown[{#NAMESPACE}/{#NAME}]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><description>Pod is in unknown state.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_pod_status_phase{pod=&quot;{#NAME}&quot;, phase=&quot;Unknown&quot;}</parameter><parameter>value</parameter><parameter/></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>pod</value></tag><tag><tag>namespace</tag><value>{#NAMESPACE}</value></tag><tag><tag>phase</tag><value>unknown</value></tag><tag><tag>pod</tag><value>{#NAME}</value></tag></tags></item_prototype><item_prototype><uuid>d946bc58d5a44aa9936b09c825a51f59</uuid><name>Kubernetes: Namespace [{#NAMESPACE}] Pod [{#NAME}]: Ready</name><type>DEPENDENT</type><key>kube.pod.ready[{#NAMESPACE}/{#NAME}]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><description>Describes whether the pod is ready to serve requests.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_pod_status_ready{pod=&quot;{#NAME}&quot;, condition=&quot;true&quot;}</parameter><parameter>value</parameter><parameter/></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>pod</value></tag><tag><tag>namespace</tag><value>{#NAMESPACE}</value></tag><tag><tag>pod</tag><value>{#NAME}</value></tag><tag><tag>status</tag><value>ready</value></tag></tags></item_prototype><item_prototype><uuid>0f858209a4b344de80b1382710c6f153</uuid><name>Kubernetes: Namespace [{#NAMESPACE}] Pod [{#NAME}]: Scheduled</name><type>DEPENDENT</type><key>kube.pod.scheduled[{#NAMESPACE}/{#NAME}]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><description>Describes the status of the scheduling process for the pod.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_pod_status_scheduled{pod=&quot;{#NAME}&quot;, condition=&quot;true&quot;}</parameter><parameter>value</parameter><parameter/></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>pod</value></tag><tag><tag>namespace</tag><value>{#NAMESPACE}</value></tag><tag><tag>pod</tag><value>{#NAME}</value></tag><tag><tag>status</tag><value>scheduled</value></tag></tags></item_prototype><item_prototype><uuid>93ba93d04ec34b5193252f19a33f5d59</uuid><name>Kubernetes: Namespace [{#NAMESPACE}] Pod [{#NAME}]: Unschedulable</name><type>DEPENDENT</type><key>kube.pod.unschedulable[{#NAMESPACE}/{#NAME}]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><description>Describes the unschedulable status for the pod.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_pod_status_unschedulable{pod=&quot;{#NAME}&quot;}</parameter><parameter>value</parameter><parameter/></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>pod</value></tag><tag><tag>namespace</tag><value>{#NAMESPACE}</value></tag><tag><tag>pod</tag><value>{#NAME}</value></tag><tag><tag>status</tag><value>unschedulable</value></tag></tags></item_prototype></item_prototypes><trigger_prototypes><trigger_prototype><uuid>5bf79dee7b974064b5848a7dcf6428c2</uuid><expression>min(/Kubernetes cluster state by HTTP/kube.pod.phase.failed[{#NAMESPACE}/{#NAME}],10m)&gt;0 or min(/Kubernetes cluster state by HTTP/kube.pod.phase.pending[{#NAMESPACE}/{#NAME}],10m)&gt;0 or min(/Kubernetes cluster state by HTTP/kube.pod.phase.unknown[{#NAMESPACE}/{#NAME}],10m)&gt;0</expression><name>Kubernetes: Namespace [{#NAMESPACE}] Pod [{#NAME}]: Pod is not healthy</name><priority>HIGH</priority><tags><tag><tag>scope</tag><value>availability</value></tag></tags></trigger_prototype></trigger_prototypes><master_item><key>kube.state.metrics</key></master_item><preprocessing><step><type>PROMETHEUS_TO_JSON</type><parameters><parameter>kube_pod_start_time</parameter></parameters></step><step><type>JAVASCRIPT</type><parameters><parameter>var input = JSON.parse(value),
    output = [];

input.forEach(function (metric) {
    output.push({
        '{#NAME}': metric.labels.pod,
        '{#NAMESPACE}': metric.labels.namespace
    });
});

return JSON.stringify(output);</parameter></parameters></step><step><type>DISCARD_UNCHANGED_HEARTBEAT</type><parameters><parameter>3h</parameter></parameters></step></preprocessing></discovery_rule><discovery_rule><uuid>4143b2f294ac45a5ab570a94a626fca6</uuid><name>PVC discovery</name><type>DEPENDENT</type><key>kube.pvc.discovery</key><delay>0</delay><filter><evaltype>AND</evaltype><conditions><condition><macro>{#NAMESPACE}</macro><value>{$KUBE.LLD.FILTER.NAMESPACE.MATCHES}</value><formulaid>A</formulaid></condition><condition><macro>{#NAMESPACE}</macro><value>{$KUBE.LLD.FILTER.NAMESPACE.NOT_MATCHES}</value><operator>NOT_MATCHES_REGEX</operator><formulaid>B</formulaid></condition></conditions></filter><lifetime>0</lifetime><item_prototypes><item_prototype><uuid>9187144531f145398bfbe7281290533d</uuid><name>Kubernetes: Namespace [{#NAMESPACE}] PVC [{#NAME}] Requested storage</name><type>DEPENDENT</type><key>kube.pvc.requested.storage[{#NAMESPACE}/{#NAME}]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><units>B</units><description>The capacity of storage requested by the persistent volume claim.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_persistentvolumeclaim_resource_requests_storage_bytes{namespace=&quot;{#NAMESPACE}&quot;, name=&quot;{#NAME}&quot;}</parameter><parameter>value</parameter><parameter/></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>pvc</value></tag><tag><tag>namespace</tag><value>{#NAMESPACE}</value></tag><tag><tag>phase</tag><value>requested</value></tag><tag><tag>phase</tag><value>{#NAME}</value></tag></tags></item_prototype><item_prototype><uuid>6bbe0a1846834467b6147ecfe0c53035</uuid><name>Kubernetes: Namespace [{#NAMESPACE}] Status phase: Active, sum</name><type>DEPENDENT</type><key>kube.pvc.status_phase.active.sum[{#NAMESPACE}/{#NAME}]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><description>Persistent volume claim is currently in Active phase.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_persistentvolumeclaim_status_phase{namespace=&quot;{#NAMESPACE}&quot;, persistentvolumeclaim=&quot;{#NAME}&quot;, phase=&quot;Active&quot;}</parameter><parameter>function</parameter><parameter>sum</parameter></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>pvc</value></tag><tag><tag>namespace</tag><value>{#NAMESPACE}</value></tag><tag><tag>phase</tag><value>active</value></tag><tag><tag>phase</tag><value>{#NAME}</value></tag></tags></item_prototype><item_prototype><uuid>49b5eb7d714c4b019178c96e44af1216</uuid><name>Kubernetes: Namespace [{#NAMESPACE}] PVC [{#NAME}] Status phase: Available</name><type>DEPENDENT</type><key>kube.pvc.status_phase.active[{#NAMESPACE}/{#NAME}]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><description>Persistent volume claim is currently in Active phase.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_persistentvolumeclaim_status_phase{namespace=&quot;{#NAMESPACE}&quot;, name=&quot;{#NAME}&quot;, phase=&quot;Available&quot;}</parameter><parameter>value</parameter><parameter/></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>pvc</value></tag><tag><tag>namespace</tag><value>{#NAMESPACE}</value></tag><tag><tag>phase</tag><value>active</value></tag><tag><tag>pvc</tag><value>{#NAME}</value></tag></tags></item_prototype><item_prototype><uuid>c6560c039b894af6a264a0f509491c1f</uuid><name>Kubernetes: Namespace [{#NAMESPACE}] Status phase: Bound, sum</name><type>DEPENDENT</type><key>kube.pvc.status_phase.bound.sum[{#NAMESPACE}/{#NAME}]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><description>Persistent volume claim is currently in Bound phase.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_persistentvolumeclaim_status_phase{namespace=&quot;{#NAMESPACE}&quot;, persistentvolumeclaim=&quot;{#NAME}&quot;, phase=&quot;Bound&quot;}</parameter><parameter>function</parameter><parameter>sum</parameter></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>pvc</value></tag><tag><tag>namespace</tag><value>{#NAMESPACE}</value></tag><tag><tag>phase</tag><value>bound</value></tag><tag><tag>phase</tag><value>{#NAME}</value></tag></tags></item_prototype><item_prototype><uuid>8a979a9baf4e42aeb708be9af81c14c4</uuid><name>Kubernetes: Namespace [{#NAMESPACE}] PVC [{#NAME}] Status phase: Bound</name><type>DEPENDENT</type><key>kube.pvc.status_phase.bound[{#NAMESPACE}/{#NAME}]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><description>Persistent volume claim is currently in Bound phase.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_persistentvolumeclaim_status_phase{namespace=&quot;{#NAMESPACE}&quot;, name=&quot;{#NAME}&quot;, phase=&quot;Bound&quot;}</parameter><parameter>value</parameter><parameter/></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>pvc</value></tag><tag><tag>namespace</tag><value>{#NAMESPACE}</value></tag><tag><tag>phase</tag><value>bound</value></tag><tag><tag>pvc</tag><value>{#NAME}</value></tag></tags></item_prototype><item_prototype><uuid>6810603a92d941afa29dc2e9314d92ae</uuid><name>Kubernetes: Namespace [{#NAMESPACE}] Status phase: Lost, sum</name><type>DEPENDENT</type><key>kube.pvc.status_phase.lost.sum[{#NAMESPACE}/{#NAME}]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><description>Persistent volume claim is currently in Lost phase.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_persistentvolumeclaim_status_phase{namespace=&quot;{#NAMESPACE}&quot;,persistentvolumeclaim=&quot;{#NAME}&quot;, phase=&quot;Lost&quot;}</parameter><parameter>function</parameter><parameter>sum</parameter></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>pvc</value></tag><tag><tag>namespace</tag><value>{#NAMESPACE}</value></tag><tag><tag>phase</tag><value>lost</value></tag><tag><tag>phase</tag><value>{#NAME}</value></tag></tags></item_prototype><item_prototype><uuid>0e08b33ba95f4f8d811ace1fcbe44fc7</uuid><name>Kubernetes: Namespace [{#NAMESPACE}] PVC [{#NAME}] Status phase: Lost</name><type>DEPENDENT</type><key>kube.pvc.status_phase.lost[{#NAMESPACE}/{#NAME}]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><description>Persistent volume claim is currently in Lost phase.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_persistentvolumeclaim_status_phase{namespace=&quot;{#NAMESPACE}&quot;, name=&quot;{#NAME}&quot;, phase=&quot;Lost&quot;}</parameter><parameter>value</parameter><parameter/></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>pvc</value></tag><tag><tag>namespace</tag><value>{#NAMESPACE}</value></tag><tag><tag>phase</tag><value>lost</value></tag><tag><tag>pvc</tag><value>{#NAME}</value></tag></tags></item_prototype><item_prototype><uuid>1227e04d6b374154bbf07f1cf64eebeb</uuid><name>Kubernetes: Namespace [{#NAMESPACE}] Status phase: Pending, sum</name><type>DEPENDENT</type><key>kube.pvc.status_phase.pending.sum[{#NAMESPACE}/{#NAME}]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><description>Persistent volume claim is currently in Pending phase.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_persistentvolumeclaim_status_phase{namespace=&quot;{#NAMESPACE}&quot;, persistentvolumeclaim=&quot;{#NAME}&quot;, phase=&quot;Pending&quot;}</parameter><parameter>function</parameter><parameter>sum</parameter></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>pvc</value></tag><tag><tag>namespace</tag><value>{#NAMESPACE}</value></tag><tag><tag>phase</tag><value>pending</value></tag><tag><tag>pvc</tag><value>{#NAME}</value></tag></tags></item_prototype><item_prototype><uuid>6ab12b7a2ad345a090c3dc36d604d800</uuid><name>Kubernetes: Namespace [{#NAMESPACE}] PVC [{#NAME}] Status phase: Pending</name><type>DEPENDENT</type><key>kube.pvc.status_phase.pending[{#NAMESPACE}/{#NAME}]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><description>Persistent volume claim is currently in Pending phase.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_persistentvolumeclaim_status_phase{namespace=&quot;{#NAMESPACE}&quot;, name=&quot;{#NAME}&quot;, phase=&quot;Pending&quot;}</parameter><parameter>value</parameter><parameter/></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>pvc</value></tag><tag><tag>namespace</tag><value>{#NAMESPACE}</value></tag><tag><tag>phase</tag><value>pending</value></tag><tag><tag>pvc</tag><value>{#NAME}</value></tag></tags><trigger_prototypes><trigger_prototype><uuid>75a1b90ae3f14a52a0f5d7d073332042</uuid><expression>min(/Kubernetes cluster state by HTTP/kube.pvc.status_phase.pending[{#NAMESPACE}/{#NAME}],2m)&gt;0</expression><name>Kubernetes: NS [{#NAMESPACE}] PVC [{#NAME}]: PVC is pending</name><priority>WARNING</priority><tags><tag><tag>scope</tag><value>availability</value></tag></tags></trigger_prototype></trigger_prototypes></item_prototype></item_prototypes><master_item><key>kube.state.metrics</key></master_item><preprocessing><step><type>PROMETHEUS_TO_JSON</type><parameters><parameter>kube_persistentvolumeclaim_info</parameter></parameters></step><step><type>JAVASCRIPT</type><parameters><parameter>var input = JSON.parse(value),
    output = [];

input.forEach(function (metric) {
    output.push({
        '{#NAME}': metric.labels.persistentvolumeclaim,
        '{#NAMESPACE}': metric.labels.namespace

    });
});

return JSON.stringify(output);</parameter></parameters></step><step><type>DISCARD_UNCHANGED_HEARTBEAT</type><parameters><parameter>3h</parameter></parameters></step></preprocessing></discovery_rule><discovery_rule><uuid>ee274767c42345e3a501f43e81a3364a</uuid><name>Readyz discovery</name><type>DEPENDENT</type><key>kube.readyz.discovery</key><delay>0</delay><item_prototypes><item_prototype><uuid>c0693fb2709e4b01a35ca433edb84db7</uuid><name>Kubernetes: Readyz [{#NAME}]: Healthcheck</name><type>DEPENDENT</type><key>kube.readyz.healthcheck[{#NAME}]</key><delay>0</delay><history>7d</history><trends>0</trends><value_type>CHAR</value_type><description>Result of readyz healthcheck for component.</description><preprocessing><step><type>JSONPATH</type><parameters><parameter>$.[?(@.name == &quot;{#NAME}&quot;)].value.first()</parameter></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.readyz</key></master_item><tags><tag><tag>component</tag><value>readyz</value></tag><tag><tag>component</tag><value>{#NAME}</value></tag></tags><trigger_prototypes><trigger_prototype><uuid>1a88c2cf94d3444c9e5320776b323ce6</uuid><expression>count(/Kubernetes cluster state by HTTP/kube.readyz.healthcheck[{#NAME}],#3,,&quot;ok&quot;)&lt;2 and length(last(/Kubernetes cluster state by HTTP/kube.readyz.healthcheck[{#NAME}]))&gt;0</expression><name>Kubernetes: Readyz [{#NAME}] is unhealthy</name><priority>WARNING</priority><tags><tag><tag>scope</tag><value>availability</value></tag></tags></trigger_prototype></trigger_prototypes></item_prototype></item_prototypes><master_item><key>kube.readyz</key></master_item><preprocessing><step><type>JAVASCRIPT</type><parameters><parameter>var input = JSON.parse(value),
    output = [];

input.forEach(function (component) {
    output.push({
        '{#NAME}': component.name
    });
});

return JSON.stringify(output);</parameter></parameters></step><step><type>DISCARD_UNCHANGED_HEARTBEAT</type><parameters><parameter>3h</parameter></parameters></step></preprocessing></discovery_rule><discovery_rule><uuid>6244f250f6cd411080221843ad1c59f2</uuid><name>Replicaset discovery</name><type>DEPENDENT</type><key>kube.replicaset.discovery</key><delay>0</delay><filter><evaltype>AND</evaltype><conditions><condition><macro>{#NAMESPACE}</macro><value>{$KUBE.LLD.FILTER.NAMESPACE.MATCHES}</value><formulaid>A</formulaid></condition><condition><macro>{#NAMESPACE}</macro><value>{$KUBE.LLD.FILTER.NAMESPACE.NOT_MATCHES}</value><operator>NOT_MATCHES_REGEX</operator><formulaid>B</formulaid></condition></conditions></filter><lifetime>0</lifetime><item_prototypes><item_prototype><uuid>928536dae27c4e3497627b9f5642a7a8</uuid><name>Kubernetes: Namespace [{#NAMESPACE}] Replicaset [{#NAME}]: Fully labeled replicas</name><type>DEPENDENT</type><key>kube.replicaset.fully_labeled_replicas[{#NAMESPACE}/{#NAME}]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><description>The number of fully labeled replicas per ReplicaSet.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_replicaset_status_fully_labeled_replicas{namespace=&quot;{#NAMESPACE}&quot;, replicaset=&quot;{#NAME}&quot;}</parameter><parameter>value</parameter><parameter/></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>replicaset</value></tag><tag><tag>namespace</tag><value>{#NAMESPACE}</value></tag><tag><tag>replicaset</tag><value>{#NAME}</value></tag><tag><tag>status</tag><value>fully-labeled</value></tag></tags></item_prototype><item_prototype><uuid>4e911e4b71c342dba2227ed7ef360190</uuid><name>Kubernetes: Namespace [{#NAMESPACE}] Replicaset [{#NAME}]: Ready</name><type>DEPENDENT</type><key>kube.replicaset.ready[{#NAMESPACE}/{#NAME}]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><description>The number of ready replicas per ReplicaSet.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_replicaset_status_ready_replicas{namespace=&quot;{#NAMESPACE}&quot;, replicaset=&quot;{#NAME}&quot;}</parameter><parameter>value</parameter><parameter/></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>replicaset</value></tag><tag><tag>namespace</tag><value>{#NAMESPACE}</value></tag><tag><tag>replicaset</tag><value>{#NAME}</value></tag><tag><tag>status</tag><value>ready</value></tag></tags></item_prototype><item_prototype><uuid>545c8486dcc9409c93c6efee0f4b2ad6</uuid><name>Kubernetes: Namespace [{#NAMESPACE}] Replicaset [{#NAME}]: Replicas</name><type>DEPENDENT</type><key>kube.replicaset.replicas[{#NAMESPACE}/{#NAME}]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><description>The number of replicas per ReplicaSet.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_replicaset_status_replicas{namespace=&quot;{#NAMESPACE}&quot;, replicaset=&quot;{#NAME}&quot;}</parameter><parameter>value</parameter><parameter/></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>replicaset</value></tag><tag><tag>namespace</tag><value>{#NAMESPACE}</value></tag><tag><tag>replicaset</tag><value>{#NAME}</value></tag></tags></item_prototype><item_prototype><uuid>30aea656c8a5470ea4566333077628b3</uuid><name>Kubernetes: Namespace [{#NAMESPACE}] Replicaset [{#NAME}]: Desired replicas</name><type>DEPENDENT</type><key>kube.replicaset.replicas_desired[{#NAMESPACE}/{#NAME}]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><description>Number of desired pods for a ReplicaSet.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_replicaset_spec_replicas{namespace=&quot;{#NAMESPACE}&quot;, replicaset=&quot;{#NAME}&quot;}</parameter><parameter>value</parameter><parameter/></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>replicaset</value></tag><tag><tag>namespace</tag><value>{#NAMESPACE}</value></tag><tag><tag>replicaset</tag><value>{#NAME}</value></tag><tag><tag>status</tag><value>desired</value></tag></tags></item_prototype></item_prototypes><trigger_prototypes><trigger_prototype><uuid>8046757dbd3b459c9cd9f7bd369dd416</uuid><expression>(last(/Kubernetes cluster state by HTTP/kube.replicaset.replicas[{#NAMESPACE}/{#NAME}])-last(/Kubernetes cluster state by HTTP/kube.replicaset.ready[{#NAMESPACE}/{#NAME}]))&lt;&gt;0</expression><name>Kubernetes: Namespace [{#NAMESPACE}] RS [{#NAME}]: ReplicasSet mismatch</name><priority>WARNING</priority><tags><tag><tag>scope</tag><value>availability</value></tag></tags></trigger_prototype></trigger_prototypes><master_item><key>kube.state.metrics</key></master_item><preprocessing><step><type>PROMETHEUS_TO_JSON</type><parameters><parameter>kube_replicaset_status_replicas</parameter></parameters></step><step><type>JAVASCRIPT</type><parameters><parameter>var input = JSON.parse(value),
    output = [];

input.forEach(function (metric) {
    output.push({
        '{#NAME}': metric.labels.replicaset,
        '{#NAMESPACE}': metric.labels.namespace
    });
});

return JSON.stringify(output);</parameter></parameters></step><step><type>DISCARD_UNCHANGED_HEARTBEAT</type><parameters><parameter>3h</parameter></parameters></step></preprocessing></discovery_rule><discovery_rule><uuid>f732cbb0e71e4ab896c973e355d7a6a4</uuid><name>Scheduler servers nodes discovery</name><type>DEPENDENT</type><key>kube.scheduler.discovery</key><delay>0</delay><host_prototypes><host_prototype><uuid>46da4b85c58f4c59825e61778a64a58e</uuid><host>Scheduler {#NAME}</host><name>Scheduler {#NAME}</name><group_links><group_link><group><name>Templates/Applications</name></group></group_link></group_links><group_prototypes><group_prototype><name>{#CLUSTER_HOSTNAME}: Kubernetes/Components: {#COMPONENT.SCHEDULER}</name></group_prototype></group_prototypes><templates><template><name>Kubernetes Scheduler by HTTP</name></template></templates><macros><macro><macro>{$KUBE.SCHEDULER.SERVER.URL}</macro><value>{#KUBE.SCHEDULER.SERVER.URL}</value></macro></macros><tags><tag><tag>addr</tag><value>{#IP}</value></tag></tags><custom_interfaces>YES</custom_interfaces><interfaces><interface><ip>{#IP}</ip></interface></interfaces></host_prototype></host_prototypes><master_item><key>kube.control_plane.lld</key></master_item></discovery_rule><discovery_rule><uuid>37812660877243e9bdbc0ffc7815578c</uuid><name>Statefulset discovery</name><type>DEPENDENT</type><key>kube.statefulset.discovery</key><delay>0</delay><filter><evaltype>AND</evaltype><conditions><condition><macro>{#NAMESPACE}</macro><value>{$KUBE.LLD.FILTER.NAMESPACE.MATCHES}</value><formulaid>A</formulaid></condition><condition><macro>{#NAMESPACE}</macro><value>{$KUBE.LLD.FILTER.NAMESPACE.NOT_MATCHES}</value><operator>NOT_MATCHES_REGEX</operator><formulaid>B</formulaid></condition></conditions></filter><lifetime>0</lifetime><item_prototypes><item_prototype><uuid>9cc34425228f44868f3cd46450d557ca</uuid><name>Kubernetes: Namespace [{#NAMESPACE}] Statefulset [{#NAME}]: Replicas</name><type>DEPENDENT</type><key>kube.statefulset.replicas[{#NAMESPACE}/{#NAME}]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><description>The number of replicas per StatefulSet.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_statefulset_status_replicas{namespace=&quot;{#NAMESPACE}&quot;, statefulset=&quot;{#NAME}&quot;}</parameter><parameter>value</parameter><parameter/></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>statefulset</value></tag><tag><tag>namespace</tag><value>{#NAMESPACE}</value></tag><tag><tag>statefulset</tag><value>{#NAME}</value></tag></tags></item_prototype><item_prototype><uuid>33e5a534b35f40c6ad7fef53212ef970</uuid><name>Kubernetes: Namespace [{#NAMESPACE}] Statefulset [{#NAME}]: Current replicas</name><type>DEPENDENT</type><key>kube.statefulset.replicas_current[{#NAMESPACE}/{#NAME}]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><description>The number of current replicas per StatefulSet.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_statefulset_status_replicas_current{namespace=&quot;{#NAMESPACE}&quot;, statefulset=&quot;{#NAME}&quot;}</parameter><parameter>value</parameter><parameter/></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>statefulset</value></tag><tag><tag>namespace</tag><value>{#NAMESPACE}</value></tag><tag><tag>statefulset</tag><value>{#NAME}</value></tag></tags></item_prototype><item_prototype><uuid>3fee3afc8b924b13ae24ab4b5e793acf</uuid><name>Kubernetes: Namespace [{#NAMESPACE}] Statefulset [{#NAME}]: Desired replicas</name><type>DEPENDENT</type><key>kube.statefulset.replicas_desired[{#NAMESPACE}/{#NAME}]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><description>Number of desired pods for a StatefulSet.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_statefulset_replicas{namespace=&quot;{#NAMESPACE}&quot;, statefulset=&quot;{#NAME}&quot;}</parameter><parameter>value</parameter><parameter/></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>statefulset</value></tag><tag><tag>namespace</tag><value>{#NAMESPACE}</value></tag><tag><tag>statefulset</tag><value>{#NAME}</value></tag><tag><tag>status</tag><value>ready</value></tag></tags></item_prototype><item_prototype><uuid>b35c1cebd902484998f383585ce29b76</uuid><name>Kubernetes: Namespace [{#NAMESPACE}] Statefulset [{#NAME}]: Ready replicas</name><type>DEPENDENT</type><key>kube.statefulset.replicas_ready[{#NAMESPACE}/{#NAME}]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><description>The number of ready replicas per StatefulSet.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_statefulset_status_replicas_ready{namespace=&quot;{#NAMESPACE}&quot;, statefulset=&quot;{#NAME}&quot;}</parameter><parameter>value</parameter><parameter/></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>statefulset</value></tag><tag><tag>namespace</tag><value>{#NAMESPACE}</value></tag><tag><tag>statefulset</tag><value>{#NAME}</value></tag><tag><tag>status</tag><value>ready</value></tag></tags></item_prototype><item_prototype><uuid>b00b1cfed30e4b90b9754d543e72d7aa</uuid><name>Kubernetes: Namespace [{#NAMESPACE}] Statefulset [{#NAME}]: Updated replicas</name><type>DEPENDENT</type><key>kube.statefulset.replicas_updated[{#NAMESPACE}/{#NAME}]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><description>The number of updated replicas per StatefulSet.</description><preprocessing><step><type>PROMETHEUS_PATTERN</type><parameters><parameter>kube_statefulset_status_replicas_updated{namespace=&quot;{#NAMESPACE}&quot;, statefulset=&quot;{#NAME}&quot;}</parameter><parameter>value</parameter><parameter/></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>kube.state.metrics</key></master_item><tags><tag><tag>component</tag><value>statefulset</value></tag><tag><tag>namespace</tag><value>{#NAMESPACE}</value></tag><tag><tag>statefulset</tag><value>{#NAME}</value></tag><tag><tag>status</tag><value>updated</value></tag></tags></item_prototype></item_prototypes><trigger_prototypes><trigger_prototype><uuid>469d6933f5494ca48a212cdc364058e0</uuid><expression>(last(/Kubernetes cluster state by HTTP/kube.statefulset.replicas[{#NAMESPACE}/{#NAME}])-last(/Kubernetes cluster state by HTTP/kube.statefulset.replicas_ready[{#NAMESPACE}/{#NAME}]))&lt;&gt;0</expression><name>Kubernetes: Namespace [{#NAMESPACE}] RS [{#NAME}]: Statefulset replicas mismatch</name><priority>WARNING</priority><tags><tag><tag>scope</tag><value>availability</value></tag></tags></trigger_prototype><trigger_prototype><uuid>c29a27fe5a0345c8af9e0d4e99b22dcb</uuid><expression>(last(/Kubernetes cluster state by HTTP/kube.statefulset.replicas_ready[{#NAMESPACE}/{#NAME}]) / last(/Kubernetes cluster state by HTTP/kube.statefulset.replicas_current[{#NAMESPACE}/{#NAME}]))&lt;&gt;1</expression><name>Kubernetes: Namespace [{#NAMESPACE}] StatefulSet [{#NAME}]: StatfulSet is down</name><priority>HIGH</priority><tags><tag><tag>scope</tag><value>availability</value></tag></tags></trigger_prototype></trigger_prototypes><master_item><key>kube.state.metrics</key></master_item><preprocessing><step><type>PROMETHEUS_TO_JSON</type><parameters><parameter>kube_statefulset_status_replicas</parameter></parameters></step><step><type>JAVASCRIPT</type><parameters><parameter>var input = JSON.parse(value),
    output = [];

input.forEach(function (metric) {
    output.push({
        '{#NAME}': metric.labels.statefulset,
        '{#NAMESPACE}': metric.labels.namespace
    });
});

return JSON.stringify(output);</parameter></parameters></step><step><type>DISCARD_UNCHANGED_HEARTBEAT</type><parameters><parameter>3h</parameter></parameters></step></preprocessing></discovery_rule></discovery_rules><tags><tag><tag>class</tag><value>software</value></tag><tag><tag>target</tag><value>kubernetes state</value></tag></tags><macros><macro><macro>{$KUBE.API.COMPONENTSTATUSES.ENDPOINT}</macro><value>/api/v1/componentstatuses</value><description>Kubernetes API componentstatuses endpoint /api/v1/componentstatuses</description></macro><macro><macro>{$KUBE.API.LIVEZ.ENDPOINT}</macro><value>/livez</value><description>Kubernetes API livez endpoint /livez</description></macro><macro><macro>{$KUBE.API.READYZ.ENDPOINT}</macro><value>/readyz</value><description>Kubernetes API readyz endpoint /readyz</description></macro><macro><macro>{$KUBE.API.TOKEN}</macro><description>Service account bearer token</description></macro><macro><macro>{$KUBE.API.URL}</macro><value>https://localhost:6443</value><description>Kubernetes API endpoint URL in the format &lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;</description></macro><macro><macro>{$KUBE.API_SERVER.PORT}</macro><value>6443</value><description>Kubernetes API servers metrics endpoint port. Used in ControlPlane LLD.</description></macro><macro><macro>{$KUBE.API_SERVER.SCHEME}</macro><value>https</value><description>Kubernetes API servers metrics endpoint scheme. Used in ControlPlane LLD.</description></macro><macro><macro>{$KUBE.CONTROLLER_MANAGER.PORT}</macro><value>10252</value><description>Kubernetes Controller manager metrics endpoint port. Used in ControlPlane LLD.</description></macro><macro><macro>{$KUBE.CONTROLLER_MANAGER.SCHEME}</macro><value>http</value><description>Kubernetes Controller manager metrics endpoint scheme. Used in ControlPlane LLD.</description></macro><macro><macro>{$KUBE.KUBELET.PORT}</macro><value>10250</value><description>Kubernetes Kubelet manager metrics endpoint port. Used in Kubelet LLD.</description></macro><macro><macro>{$KUBE.KUBELET.SCHEME}</macro><value>https</value><description>Kubernetes Kubelet manager metrics endpoint scheme. Used in Kubelet LLD.</description></macro><macro><macro>{$KUBE.LLD.FILTER.NAMESPACE.MATCHES}</macro><value>.*</value><description>Filter of discoverable pods by namespace</description></macro><macro><macro>{$KUBE.LLD.FILTER.NAMESPACE.NOT_MATCHES}</macro><value>CHANGE_IF_NEEDED</value><description>Filter to exclude discovered pods by namespace</description></macro><macro><macro>{$KUBE.LLD.FILTER.NODE.MATCHES}</macro><value>.*</value><description>Filter of discoverable nodes by nodename</description></macro><macro><macro>{$KUBE.LLD.FILTER.NODE.NOT_MATCHES}</macro><value>CHANGE_IF_NEEDED</value><description>Filter to exclude discovered nodes by nodename</description></macro><macro><macro>{$KUBE.LLD.FILTER.WORKER_NODE.MATCHES}</macro><value>.*</value><description>Filter of discoverable worker nodes by nodename</description></macro><macro><macro>{$KUBE.LLD.FILTER.WORKER_NODE.NOT_MATCHES}</macro><value>CHANGE_IF_NEEDED</value><description>Filter to exclude discovered worker nodes by nodename</description></macro><macro><macro>{$KUBE.SCHEDULER.PORT}</macro><value>10251</value><description>Kubernetes Scheduler manager metrics endpoint port. Used in ControlPlane LLD.</description></macro><macro><macro>{$KUBE.SCHEDULER.SCHEME}</macro><value>http</value><description>Kubernetes Scheduler manager metrics endpoint scheme. Used in ControlPlane LLD.</description></macro><macro><macro>{$KUBE.STATE.ENDPOINT.NAME}</macro><value>zabbix-kube-state-metrics</value><description>Kubernetes state endpoint name</description></macro></macros><valuemaps><valuemap><uuid>a435f7e23050406ca40cf6f5f872b5a7</uuid><name>CronJob suspend flag</name><mappings><mapping><value>0</value><newvalue>False</newvalue></mapping><mapping><value>1</value><newvalue>True</newvalue></mapping></mappings></valuemap></valuemaps></template></templates></zabbix_export>
