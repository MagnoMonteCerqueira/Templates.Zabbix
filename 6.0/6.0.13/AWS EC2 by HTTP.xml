<?xml version="1.0" encoding="UTF-8"?>
<zabbix_export><version>6.0</version><date>2023-02-11T16:15:10Z</date><groups><group><uuid>c2c162144c2d4c5491c8801193af4945</uuid><name>Templates/Cloud</name></group></groups><templates><template><uuid>7af6d68b223a43d4bf8526cc5dc3fe2e</uuid><template>AWS EC2 by HTTP</template><name>AWS EC2 by HTTP</name><description>Get AWS EC2 and attached AWS EBS volumes metrics and uses the script item to make HTTP requests to the CloudWatch API.
Don't forget to read the README.md for the correct setup of the template.

You can discuss this template or leave feedback on our forum https://www.zabbix.com/forum/zabbix-suggestions-and-feedback

Template tooling version used: 0.42</description><groups><group><name>Templates/Cloud</name></group></groups><items><item><uuid>22b61bf7ebba43e8aef544385448d18c</uuid><name>AWS EC2: Get alarms check</name><type>DEPENDENT</type><key>aws.ec2.alarms.check</key><delay>0</delay><history>7d</history><trends>0</trends><value_type>CHAR</value_type><description>Data collection check.</description><preprocessing><step><type>JSONPATH</type><parameters><parameter>$.error</parameter></parameters><error_handler>CUSTOM_VALUE</error_handler></step><step><type>DISCARD_UNCHANGED_HEARTBEAT</type><parameters><parameter>3h</parameter></parameters></step></preprocessing><master_item><key>aws.ec2.get_alarms</key></master_item><tags><tag><tag>component</tag><value>status</value></tag></tags><triggers><trigger><uuid>1d017a1213fb4bc9896add10a2b97dd6</uuid><expression>length(last(/AWS EC2 by HTTP/aws.ec2.alarms.check))&gt;0</expression><name>AWS EC2: Failed to get alarms data</name><priority>WARNING</priority><tags><tag><tag>scope</tag><value>availability</value></tag></tags></trigger></triggers></item><item><uuid>0384bacca1e14994a5c38dc55b73e8bb</uuid><name>AWS EC2: Credit CPU: Balance</name><type>DEPENDENT</type><key>aws.ec2.cpu.credit_balance</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><description>The number of earned CPU credits that an instance has accrued since it was launched or started. For T2 Standard, the CPUCreditBalance also includes the number of launch credits that have been accrued.
Credits are accrued in the credit balance after they are earned, and removed from the credit balance when they are spent. The credit balance has a maximum limit, determined by the instance size. After the limit is reached, any new credits that are earned are discarded. For T2 Standard, launch credits do not count towards the limit.
The credits in the CPUCreditBalance are available for the instance to spend to burst beyond its baseline CPU utilization.
When an instance is running, credits in the CPUCreditBalance do not expire. When a T3 or T3a instance stops, the CPUCreditBalance value persists for seven days. Thereafter, all accrued credits are lost. When a T2 instance stops, the CPUCreditBalance value does not persist, and all accrued credits are lost.</description><preprocessing><step><type>JSONPATH</type><parameters><parameter>$.[?(@.Label == &quot;CPUCreditBalance&quot;)].Values.first().first()</parameter></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>aws.ec2.get_metrics</key></master_item><tags><tag><tag>component</tag><value>cpu</value></tag><tag><tag>component</tag><value>credit</value></tag></tags><triggers><trigger><uuid>4e67cac1f58a478fb0e47c52b402fd92</uuid><expression>max(/AWS EC2 by HTTP/aws.ec2.cpu.credit_balance,5m)&lt;{$AWS.EC2.CPU.CREDIT.BALANCE.MIN.WARN}</expression><name>AWS EC2: Instance CPU Credit balance is too low</name><event_name>AWS EC2: Instance CPU Credit balance is too low (less {$AWS.EC2.CPU.CREDIT.BALANCE.MIN.WARN} for 5m)</event_name><opdata>Current value: {ITEM.LASTVALUE1}</opdata><priority>WARNING</priority><description>The number of earned CPU credits has been less than {$AWS.EC2.CPU.CREDIT.BALANCE.MIN.WARN} in the last 5 minutes.</description><tags><tag><tag>scope</tag><value>capacity</value></tag></tags></trigger></triggers></item><item><uuid>b445a56de3194f6f9b4bf9dd85fcbe52</uuid><name>AWS EC2: Credit CPU: Usage</name><type>DEPENDENT</type><key>aws.ec2.cpu.credit_usage</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><description>The number of CPU credits spent by the instance for CPU utilization.
One CPU credit equals one vCPU running at 100% utilization for one minute or an equivalent combination of vCPUs, utilization, and time (for example, one vCPU running at 50% utilization for two minutes or two vCPUs running at 25% utilization for two minutes).</description><preprocessing><step><type>JSONPATH</type><parameters><parameter>$.[?(@.Label == &quot;CPUCreditUsage&quot;)].Values.first().first()</parameter></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>aws.ec2.get_metrics</key></master_item><tags><tag><tag>component</tag><value>cpu</value></tag><tag><tag>component</tag><value>credit</value></tag></tags></item><item><uuid>285ec6451412450c963e3a24d2aa74e1</uuid><name>AWS EC2: Credit CPU: Surplus balance</name><type>DEPENDENT</type><key>aws.ec2.cpu.surplus_credit_balance</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><description>The number of surplus credits that have been spent by an unlimited instance when its CPUCreditBalance value is zero.
The CPUSurplusCreditBalance value is paid down by earned CPU credits. If the number of surplus credits exceeds the maximum number of credits that the instance can earn in a 24-hour period, the spent surplus credits above the maximum incur an additional charge.</description><preprocessing><step><type>JSONPATH</type><parameters><parameter>$.[?(@.Label == &quot;CPUSurplusCreditBalance&quot;)].Values.first().first()</parameter></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>aws.ec2.get_metrics</key></master_item><tags><tag><tag>component</tag><value>cpu</value></tag><tag><tag>component</tag><value>credit</value></tag></tags></item><item><uuid>77a32118a77e4836a945c7b0954ef64a</uuid><name>AWS EC2: Credit CPU: Surplus charged</name><type>DEPENDENT</type><key>aws.ec2.cpu.surplus_credit_charged</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><description>The number of spent surplus credits that are not paid down by earned CPU credits, and which thus incur an additional charge.

Spent surplus credits are charged when any of the following occurs:
- The spent surplus credits exceed the maximum number of credits that the instance can earn in a 24-hour period. Spent surplus credits above the maximum are charged at the end of the hour;
- The instance is stopped or terminated;
- The instance is switched from unlimited to standard.</description><preprocessing><step><type>JSONPATH</type><parameters><parameter>$.[?(@.Label == &quot;CPUSurplusCreditsCharged&quot;)].Values.first().first()</parameter></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>aws.ec2.get_metrics</key></master_item><tags><tag><tag>component</tag><value>cpu</value></tag><tag><tag>component</tag><value>credit</value></tag></tags><triggers><trigger><uuid>644ace5510164f329d9af65bd0ed4f34</uuid><expression>last(/AWS EC2 by HTTP/aws.ec2.cpu.surplus_credit_charged)&gt;{$AWS.EC2.CPU.CREDIT.SURPLUS.BALANCE.MAX.WARN}</expression><name>AWS EC2: Instance has spent too many CPU surplus credits</name><event_name>AWS EC2: Instance has spent too many CPU surplus credits (over {$AWS.EC2.CPU.CREDIT.SURPLUS.BALANCE.MAX.WARN} for 15m)'</event_name><opdata>Current value: {ITEM.LASTVALUE1}</opdata><priority>WARNING</priority><description>The number of spent surplus credits that are not paid down and which thus incur an additional charge is over {$AWS.EC2.CPU.CREDIT.SURPLUS.BALANCE.MAX.WARN}.</description><tags><tag><tag>scope</tag><value>capacity</value></tag></tags></trigger></triggers></item><item><uuid>7fd871e7eed54845ad069c3e7d3cad56</uuid><name>AWS EC2: CPU: Utilization</name><type>DEPENDENT</type><key>aws.ec2.cpu_utilization</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><units>%</units><description>The percentage of allocated EC2 compute units that are currently in use on the instance. This metric identifies the processing power required to run an application on a selected instance.
Depending on the instance type, tools in your operating system can show a lower percentage than CloudWatch when the instance is not allocated a full processor core.</description><preprocessing><step><type>JSONPATH</type><parameters><parameter>$.[?(@.Label == &quot;CPUUtilization&quot;)].Values.first().first()</parameter></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>aws.ec2.get_metrics</key></master_item><tags><tag><tag>component</tag><value>cpu</value></tag></tags><triggers><trigger><uuid>ea74d00067874b609e4846847033058f</uuid><expression>min(/AWS EC2 by HTTP/aws.ec2.cpu_utilization,15m)&gt;{$AWS.EC2.CPU.UTIL.WARN.MAX}</expression><name>AWS EC2: High CPU utilization</name><event_name>AWS EC2: High CPU utilization (over {$AWS.EC2.CPU.UTIL.WARN.MAX}% for 15m)</event_name><opdata>Current utilization: {ITEM.LASTVALUE1}</opdata><priority>WARNING</priority><description>CPU utilization is too high. The system might be slow to respond.</description><tags><tag><tag>scope</tag><value>capacity</value></tag><tag><tag>scope</tag><value>performance</value></tag></tags></trigger></triggers></item><item><uuid>49aecab5c7df407b9cbfe80ad8790492</uuid><name>AWS EC2: Disk: Read bytes, rate</name><type>DEPENDENT</type><key>aws.ec2.disk.read_bytes.rate</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><units>Bps</units><description>Bytes read from all instance store volumes available to the instance.
This metric is used to determine the volume of the data the application reads from the hard disk of the instance.
This can be used to determine the speed of the application.
If there are no instance store volumes, either the value is 0 or the metric is not reported.</description><preprocessing><step><type>JSONPATH</type><parameters><parameter>$.[?(@.Label == &quot;DiskReadBytes&quot;)].Values.first().first()</parameter></parameters><error_handler>DISCARD_VALUE</error_handler></step><step><type>JAVASCRIPT</type><parameters><parameter>return value / 300</parameter></parameters></step></preprocessing><master_item><key>aws.ec2.get_metrics</key></master_item><tags><tag><tag>component</tag><value>disk</value></tag></tags></item><item><uuid>d6bb726f9f1b4d5b889ede0ae2c73613</uuid><name>AWS EC2: Disk: Read, rate</name><type>DEPENDENT</type><key>aws.ec2.disk.read_ops.rate</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><units>Ops</units><description>Completed read operations from all instance store volumes available to the instance in a specified period of time.
If there are no instance store volumes, either the value is 0 or the metric is not reported.</description><preprocessing><step><type>JSONPATH</type><parameters><parameter>$.[?(@.Label == &quot;DiskReadOps&quot;)].Values.first().first()</parameter></parameters><error_handler>DISCARD_VALUE</error_handler></step><step><type>JAVASCRIPT</type><parameters><parameter>return value / 300</parameter></parameters></step></preprocessing><master_item><key>aws.ec2.get_metrics</key></master_item><tags><tag><tag>component</tag><value>disk</value></tag></tags></item><item><uuid>95bcfd522147498688555e2cab5c00e2</uuid><name>AWS EC2: Disk: Write bytes, rate</name><type>DEPENDENT</type><key>aws.ec2.disk_write_bytes.rate</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><units>Bps</units><description>Bytes written to all instance store volumes available to the instance.
This metric is used to determine the volume of the data the application writes onto the hard disk of the instance.
This can be used to determine the speed of the application.
If there are no instance store volumes, either the value is 0 or the metric is not reported.</description><preprocessing><step><type>JSONPATH</type><parameters><parameter>$.[?(@.Label == &quot;DiskWriteBytes&quot;)].Values.first().first()</parameter></parameters><error_handler>DISCARD_VALUE</error_handler></step><step><type>JAVASCRIPT</type><parameters><parameter>return value / 300</parameter></parameters></step></preprocessing><master_item><key>aws.ec2.get_metrics</key></master_item><tags><tag><tag>component</tag><value>disk</value></tag></tags></item><item><uuid>28496d5aa03742feb85ae000deb616d1</uuid><name>AWS EC2: Disk: Write ops, rate</name><type>DEPENDENT</type><key>aws.ec2.disk_write_ops.rate</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><units>Ops</units><description>Completed write operations to all instance store volumes available to the instance in a specified period of time.
If there are no instance store volumes, either the value is 0 or the metric is not reported.</description><preprocessing><step><type>JSONPATH</type><parameters><parameter>$.[?(@.Label == &quot;DiskWriteOps&quot;)].Values.first().first()</parameter></parameters><error_handler>DISCARD_VALUE</error_handler></step><step><type>JAVASCRIPT</type><parameters><parameter>return value / 300</parameter></parameters></step></preprocessing><master_item><key>aws.ec2.get_metrics</key></master_item><tags><tag><tag>component</tag><value>disk</value></tag></tags></item><item><uuid>64180ec5dae84f588006bb1dd0ce6980</uuid><name>AWS EC2: EBS: Byte balance</name><type>DEPENDENT</type><key>aws.ec2.ebs.byte_balance</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><units>%</units><description>Percentage of throughput credits remaining in the burst bucket for Nitro-based instances.</description><preprocessing><step><type>JSONPATH</type><parameters><parameter>$.[?(@.Label == &quot;EBSByteBalance%&quot;)].Values.first().first()</parameter></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>aws.ec2.get_metrics</key></master_item><tags><tag><tag>component</tag><value>ebs</value></tag></tags><triggers><trigger><uuid>27f3b00e295d4aeb9a2d0519e95da4e0</uuid><expression>max(/AWS EC2 by HTTP/aws.ec2.ebs.byte_balance,5m)&lt;{$AWS.EBS.BYTE.CREDIT.BALANCE.MIN.WARN}</expression><name>AWS EC2: Byte Credit balance is too low</name><event_name>AWS EC2: Byte Credit balance is too low (less {$AWS.EBS.BYTE.CREDIT.BALANCE.MIN.WARN}% for 5m)</event_name><opdata>Current value: {ITEM.LASTVALUE1}</opdata><priority>WARNING</priority><tags><tag><tag>scope</tag><value>capacity</value></tag></tags></trigger></triggers></item><item><uuid>7b8a2b6941d04cde8edc511752755c8f</uuid><name>AWS EC2: EBS: IO balance</name><type>DEPENDENT</type><key>aws.ec2.ebs.io_balance</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><units>%</units><description>Percentage of I/O credits remaining in the burst bucket for Nitro-based instances.</description><preprocessing><step><type>JSONPATH</type><parameters><parameter>$.[?(@.Label == &quot;EBSIOBalance%&quot;)].Values.first().first()</parameter></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>aws.ec2.get_metrics</key></master_item><tags><tag><tag>component</tag><value>ebs</value></tag></tags><triggers><trigger><uuid>f4b9c2238b5443eab31255422bc22d7d</uuid><expression>max(/AWS EC2 by HTTP/aws.ec2.ebs.io_balance,5m)&lt;{$AWS.EBS.IO.CREDIT.BALANCE.MIN.WARN}</expression><name>AWS EC2: I/O Credit balance is too low</name><event_name>AWS EC2: I/O Credit balance is too low (less {$AWS.EBS.IO.CREDIT.BALANCE.MIN.WARN}% for 5m)</event_name><opdata>Current value: {ITEM.LASTVALUE1}</opdata><priority>WARNING</priority><tags><tag><tag>scope</tag><value>capacity</value></tag></tags></trigger></triggers></item><item><uuid>251c9a3b0afd4930b822f7310f3fda43</uuid><name>AWS EC2: EBS: Read bytes, rate</name><type>DEPENDENT</type><key>aws.ec2.ebs.read_bytes.rate</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><units>Bps</units><description>Bytes read from all EBS volumes attached to the instance for Nitro-based instances.</description><preprocessing><step><type>JSONPATH</type><parameters><parameter>$.[?(@.Label == &quot;EBSReadBytes&quot;)].Values.first().first()</parameter></parameters><error_handler>DISCARD_VALUE</error_handler></step><step><type>JAVASCRIPT</type><parameters><parameter>return value/300</parameter></parameters></step></preprocessing><master_item><key>aws.ec2.get_metrics</key></master_item><tags><tag><tag>component</tag><value>ebs</value></tag></tags></item><item><uuid>29eff02b7c464605bc6d69a963d232b5</uuid><name>AWS EC2: EBS: Read, rate</name><type>DEPENDENT</type><key>aws.ec2.ebs.read_ops.rate</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><units>Ops</units><description>Completed read operations from all Amazon EBS volumes attached to the instance for Nitro-based instances.</description><preprocessing><step><type>JSONPATH</type><parameters><parameter>$.[?(@.Label == &quot;EBSReadOps&quot;)].Values.first().first()</parameter></parameters><error_handler>DISCARD_VALUE</error_handler></step><step><type>JAVASCRIPT</type><parameters><parameter>return value / 300</parameter></parameters></step></preprocessing><master_item><key>aws.ec2.get_metrics</key></master_item><tags><tag><tag>component</tag><value>ebs</value></tag></tags></item><item><uuid>9dafe0bcfb214d46975f570e2836e9cd</uuid><name>AWS EC2: EBS: Write bytes, rate</name><type>DEPENDENT</type><key>aws.ec2.ebs.write_bytes.rate</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><units>Bps</units><description>Bytes written to all EBS volumes attached to the instance for Nitro-based instances.</description><preprocessing><step><type>JSONPATH</type><parameters><parameter>$.[?(@.Label == &quot;EBSWriteBytes&quot;)].Values.first().first()</parameter></parameters><error_handler>DISCARD_VALUE</error_handler></step><step><type>JAVASCRIPT</type><parameters><parameter>return value/300</parameter></parameters></step></preprocessing><master_item><key>aws.ec2.get_metrics</key></master_item><tags><tag><tag>component</tag><value>ebs</value></tag></tags></item><item><uuid>2da28e61261746d6b94b244b8f0cf2a8</uuid><name>AWS EC2: EBS: Write, rate</name><type>DEPENDENT</type><key>aws.ec2.ebs.write_ops.rate</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><description>Completed write operations to all EBS volumes attached to the instance in a specified period of time.</description><preprocessing><step><type>JSONPATH</type><parameters><parameter>$.[?(@.Label == &quot;EBSWriteOps&quot;)].Values.first().first()</parameter></parameters><error_handler>DISCARD_VALUE</error_handler></step><step><type>JAVASCRIPT</type><parameters><parameter>return value / 300</parameter></parameters></step></preprocessing><master_item><key>aws.ec2.get_metrics</key></master_item><tags><tag><tag>component</tag><value>ebs</value></tag></tags></item><item><uuid>4e0b2ed29500487092148b14245839d4</uuid><name>AWS CloudWatch: Get instance alarms data</name><type>SCRIPT</type><key>aws.ec2.get_alarms</key><delay>0s;m/1</delay><history>0</history><trends>0</trends><value_type>TEXT</value_type><params>var AwsEc2 = {
   params: {},

   setParams: function (params) {
       ['access_key', 'secret_key', 'region', 'instance_id'].forEach(function (field) {
           if (typeof params !== 'object' || typeof params[field] === 'undefined' || params[field] === '') {
               throw 'Required param is not set: &quot;' + field + '&quot;.';
           }
       });

       AwsEc2.params = params;
   },

   sign: function (key, message) {
       var hex = hmac('sha256', key, message);

       if ((hex.length % 2) === 1) {
           throw 'Invalid length of a hex string!';
       }

       var result = new Int8Array(hex.length / 2);
       for (var i = 0, b = 0; i &lt; hex.length; i += 2, b++) {
           result[b] = parseInt(hex.substring(i, i + 2), 16);
       }

       return result;
   },

   prepareParams: function (params) {
       var result = [];

       Object.keys(params).sort().forEach(function (key) {
           if (typeof params[key] !== 'object') {
               result.push(key + '=' + encodeURIComponent(params[key]));
           }
           else {
               result.push(prepareObject(key, params[key]));
           }
       });

       return result.join('&amp;');
   },

   request: function (method, region, service, params, data) {
       if (typeof data === 'undefined' || data === null) {
           data = '';
       }

       var amzdate = (new Date()).toISOString().replace(/\.\d+Z/, 'Z').replace(/[-:]/g, ''),
           date = amzdate.replace(/T\d+Z/, ''),
           host = service + '.' + region + '.amazonaws.com',
           canonical_uri = '/',
           canonical_headers = 'content-encoding:amz-1.0\n' + 'host:' + host + '\n' + 'x-amz-date:' + amzdate + '\n',
           signed_headers = 'content-encoding;host;x-amz-date',
           canonical_request = method + '\n' + canonical_uri + '\n' + params + '\n' + canonical_headers + '\n' + signed_headers + '\n' + sha256(data),
           credential_scope = date + '/' + region + '/' + service + '/' + 'aws4_request',
           request_string = 'AWS4-HMAC-SHA256' + '\n' + amzdate + '\n' + credential_scope + '\n' + sha256(canonical_request),
           key = AwsEc2.sign('AWS4' + AwsEc2.params.secret_key, date);

       key = AwsEc2.sign(key, region);
       key = AwsEc2.sign(key, service);
       key = AwsEc2.sign(key, 'aws4_request');

       var request = new HttpRequest(),
           url = 'https://' + host + canonical_uri + '?' + params;

       if (typeof AwsEc2.params.proxy !== 'undefined' &amp;&amp; AwsEc2.params.proxy !== '') {
           request.setProxy(AwsEc2.params.proxy);
       }
       request.addHeader('x-amz-date: ' + amzdate);
       request.addHeader('Accept: application/json');
       request.addHeader('Content-Type: application/json');
       request.addHeader('Content-Encoding: amz-1.0');
       request.addHeader('Authorization: ' + 'AWS4-HMAC-SHA256 Credential=' + AwsEc2.params.access_key + '/' + credential_scope + ', ' + 'SignedHeaders=' + signed_headers + ', ' + 'Signature=' + hmac('sha256', key, request_string));

       Zabbix.log(4, '[ AWS EC2  ] Sending request: ' + url);

       response = request.get(url);

       Zabbix.log(4, '[ AWS EC2 ] Received response with status code ' + request.getStatus() + ': ' + response);

       if (request.getStatus() !== 200) {
           throw 'Request failed with status code ' + request.getStatus() + ': ' + response;
       }

       if (response[0] === '&lt;') {
           try {
               response = XML.toJson(response);
           }
           catch (error) {
               throw 'Failed to parse response received from AWS CloudWatch API. Check debug log for more information.';
           }
       }

       if (response !== null) {
           try {
               response = JSON.parse(response);
           }
           catch (error) {
               throw 'Failed to parse response received from AWS CloudWatch API. Check debug log for more information.';
           }
       }

       return response;
   },
   getVolumes: function () {
       var payload = {},
           result = [];

       payload['Action'] = 'DescribeVolumes',
           payload['MaxResults'] = 100,
           payload['Version'] = '2016-11-15',
           payload['Filter.1.Name'] = 'attachment.instance-id',
           payload['Filter.1.Value'] = AwsEc2.params.instance_id;

       while (payload.NextToken !== '') {
           var volumes = AwsEc2.request('GET', AwsEc2.params.region, 'ec2', AwsEc2.prepareParams(payload));
           if (typeof volumes !== 'object'
               || typeof volumes.DescribeVolumesResponse !== 'object'
               || typeof volumes.DescribeVolumesResponse.volumeSet !== 'object'
               || typeof volumes.DescribeVolumesResponse.volumeSet.item !== 'object') {
               throw 'Cannot get metrics data from AWS EC2 API. Check debug log for more information.';
           }
           payload.NextToken = volumes.DescribeVolumesResponse.NextToken || '';
           if (!Array.isArray(volumes.DescribeVolumesResponse.volumeSet.item))
               volumes.DescribeVolumesResponse.volumeSet.item = [volumes.DescribeVolumesResponse.volumeSet.item]
           volumes.DescribeVolumesResponse.volumeSet.item.forEach(function (volume) {
               result.push(volume.volumeId)
           });
       }

       return result;
   },
   getAlarms: function () {
       var payload = {},
           result = [],
           volumes = AwsEc2.getVolumes()

       payload['Action'] = 'DescribeAlarms';
       payload['MaxRecords'] = 100;
       payload['Version'] = '2010-08-01';

       while (payload.NextToken !== '') {
           var alarms = AwsEc2.request('GET', AwsEc2.params.region, 'monitoring', AwsEc2.prepareParams(payload));

           if (typeof alarms !== 'object'
               || typeof alarms.DescribeAlarmsResponse !== 'object'
               || typeof alarms.DescribeAlarmsResponse.DescribeAlarmsResult !== 'object'
               || typeof alarms.DescribeAlarmsResponse.DescribeAlarmsResult.MetricAlarms !== 'object') {
               throw 'Cannot get alarms from AWS CloudWatch API. Check debug log for more information.';
           }

           payload.NextToken = alarms.DescribeAlarmsResponse.DescribeAlarmsResult.NextToken || '';

           if (!Array.isArray(alarms.DescribeAlarmsResponse.DescribeAlarmsResult.MetricAlarms))
               alarms.DescribeAlarmsResponse.DescribeAlarmsResult.MetricAlarms = [alarms.DescribeAlarmsResponse.DescribeAlarmsResult.MetricAlarms]
           alarms.DescribeAlarmsResponse.DescribeAlarmsResult.MetricAlarms.forEach(function (alarm) {
               var dimensions = alarm.Dimensions;

               if (Array.isArray(alarm.Metrics)) {
                   alarm.Metrics.forEach(function (metric) {
                       if (typeof metric.MetricStat === 'object' &amp;&amp; metric.MetricStat !== null
                           &amp;&amp; typeof metric.MetricStat.Metric === 'object' &amp;&amp; metric.MetricStat.Metric !== null
                           &amp;&amp; Array.isArray(metric.MetricStat.Metric.Dimensions)) {
                           dimensions = dimensions.concat(metric.MetricStat.Metric.Dimensions);
                       }
                   });
               }
               for (var i in dimensions) {
                   if (dimensions[i].Name === 'InstanceId' &amp;&amp; dimensions[i].Value === AwsEc2.params.instance_id) {
                       result.push(alarm);
                       break;
                   }
                   if (dimensions[i].Name === 'VolumeId' &amp;&amp; volumes.indexOf(dimensions[i].Value)) {
                       result.push(alarm);
                       break;
                   }
               }
           });
       }

       return result;
   }
 }

 try {
     AwsEc2.setParams(JSON.parse(value));

     return JSON.stringify(AwsEc2.getAlarms());
 }
 catch (error) {
     error += (String(error).endsWith('.')) ? '' : '.';
     Zabbix.log(3, '[ AWS EC2 ] ERROR: ' + error);

     return JSON.stringify({ 'error': error });
 }</params><description>DescribeAlarms API method: https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_DescribeAlarms.html</description><preprocessing><step><type>CHECK_NOT_SUPPORTED</type><parameters><parameter/></parameters></step></preprocessing><timeout>15s</timeout><parameters><parameter><name>access_key</name><value>{$AWS.ACCESS.KEY.ID}</value></parameter><parameter><name>secret_key</name><value>{$AWS.SECRET.ACCESS.KEY}</value></parameter><parameter><name>region</name><value>{$AWS.REGION}</value></parameter><parameter><name>instance_id</name><value>{$AWS.EC2.INSTANCE.ID}</value></parameter><parameter><name>proxy</name><value>{$AWS.PROXY}</value></parameter></parameters><tags><tag><tag>component</tag><value>raw</value></tag></tags></item><item><uuid>63ab011505f24885b843a9ac48b36a84</uuid><name>AWS EC2: Get metrics data</name><type>SCRIPT</type><key>aws.ec2.get_metrics</key><delay>0s;m/5</delay><history>0</history><trends>0</trends><value_type>TEXT</value_type><params>var AwsEc2 = {
      params: {},
      request_period: 600,

      setParams: function (params) {
          ['access_key', 'secret_key', 'region', 'instance_id'].forEach(function (field) {
              if (typeof params !== 'object' || typeof params[field] === 'undefined' || params[field] === '') {
                  throw 'Required param is not set: &quot;' + field + '&quot;.';
              }
          });

          AwsEc2.params = params;
      },

      sign: function (key, message) {
          var hex = hmac('sha256', key, message);

          if ((hex.length % 2) === 1) {
              throw 'Invalid length of a hex string!';
          }

          var result = new Int8Array(hex.length / 2);
          for (var i = 0, b = 0; i &lt; hex.length; i += 2, b++) {
              result[b] = parseInt(hex.substring(i, i + 2), 16);
          }

          return result;
      },

      prepareRecursive: function (prefix, param) {
          var result = {};

          if (typeof param === 'object') {
              if (Array.isArray(param)) {
                  param.forEach(function (value, index) {
                      var nested = AwsEc2.prepareRecursive(prefix + '.member.' + (index + 1), value);
                      Object.keys(nested).forEach(function (key) {
                          result[key] = nested[key];
                      });
                  });
              }
              else {
                  Object.keys(param).forEach(function (k) {
                      var nested = AwsEc2.prepareRecursive(prefix + '.' + k, param[k]);
                      Object.keys(nested).forEach(function (key) {
                          result[key] = nested[key];
                      });
                  });
              }
          }
          else {
              result[prefix] = param;
          }

          return result;
      },

      renderPayload: function (period, instance_id) {
          var metrics_list = [
              'StatusCheckFailed:Count',
              'StatusCheckFailed_Instance:Count',
              'StatusCheckFailed_System:Count',
              'CPUUtilization:Percent',
              'NetworkIn:Bytes',
              'NetworkOut:Bytes',
              'NetworkPacketsIn:Count',
              'NetworkPacketsOut:Count',
              'DiskReadOps:Count',
              'DiskWriteOps:Count',
              'DiskReadBytes:Bytes',
              'DiskWriteBytes:Bytes',
              'MetadataNoToken:Count',
              'CPUCreditUsage:Count',
              'CPUCreditBalance:Count',
              'CPUSurplusCreditBalance:Count',
              'CPUSurplusCreditsCharged:Count',
              'EBSReadOps:Count',
              'EBSWriteOps:Count',
              'EBSReadBytes:Bytes',
              'EBSWriteBytes:Bytes',
              'EBSIOBalance %:Percent',
              'EBSByteBalance %:Percent'
          ];

          var metric_payload = [];
          metrics_list.forEach(function (metric) {
              var parts = metric.split(':', 2);
              var name = parts[0].replace(/[^a-zA-Z0-9]/g, '');
              metric_payload.push({
                  'Id': name.charAt(0).toLowerCase() + name.slice(1),
                  'MetricStat': {
                      'Metric': {
                          'MetricName': parts[0],
                          'Namespace': 'AWS/EC2',
                          'Dimensions': [
                              {
                                  'Name': 'InstanceId',
                                  'Value': instance_id
                              }
                          ]
                      },
                      'Period': period,
                      'Stat': 'Average',
                      'Unit': parts[1]
                  }
              });
          });

          return metric_payload;
      },

      prepareParams: function (params) {
          var result = [];

          Object.keys(params).sort().forEach(function (key) {
              if (typeof params[key] !== 'object') {
                  result.push(key + '=' + encodeURIComponent(params[key]));
              }
              else {
                  result.push(prepareObject(key, params[key]));
              }
          });

          return result.join('&amp;');
      },

      request: function (method, region, service, params, data) {
          if (typeof data === 'undefined' || data === null) {
              data = '';
          }

          var amzdate = (new Date()).toISOString().replace(/\.\d+Z/, 'Z').replace(/[-:]/g, ''),
              date = amzdate.replace(/T\d+Z/, ''),
              host = service + '.' + region + '.amazonaws.com',
              canonical_uri = '/',
              canonical_headers = 'content-encoding:amz-1.0\n' + 'host:' + host + '\n' + 'x-amz-date:' + amzdate + '\n',
              signed_headers = 'content-encoding;host;x-amz-date',
              canonical_request = method + '\n' + canonical_uri + '\n' + params + '\n' + canonical_headers + '\n' + signed_headers + '\n' + sha256(data),
              credential_scope = date + '/' + region + '/' + service + '/' + 'aws4_request',
              request_string = 'AWS4-HMAC-SHA256' + '\n' + amzdate + '\n' + credential_scope + '\n' + sha256(canonical_request),
              key = AwsEc2.sign('AWS4' + AwsEc2.params.secret_key, date);

          key = AwsEc2.sign(key, region);
          key = AwsEc2.sign(key, service);
          key = AwsEc2.sign(key, 'aws4_request');

          var request = new HttpRequest(),
              url = 'https://' + host + canonical_uri + '?' + params;

          if (typeof AwsEc2.params.proxy !== 'undefined' &amp;&amp; AwsEc2.params.proxy !== '') {
              request.setProxy(AwsEc2.params.proxy);
          }
          request.addHeader('x-amz-date: ' + amzdate);
          request.addHeader('Accept: application/json');
          request.addHeader('Content-Type: application/json');
          request.addHeader('Content-Encoding: amz-1.0');
          request.addHeader('Authorization: ' + 'AWS4-HMAC-SHA256 Credential=' + AwsEc2.params.access_key + '/' + credential_scope + ', ' + 'SignedHeaders=' + signed_headers + ', ' + 'Signature=' + hmac('sha256', key, request_string));

          Zabbix.log(4, '[ AWS EC2  ] Sending request: ' + url);

          response = request.get(url);

          Zabbix.log(4, '[ AWS EC2 ] Received response with status code ' + request.getStatus() + ': ' + response);

          if (request.getStatus() !== 200) {
              throw 'Request failed with status code ' + request.getStatus() + ': ' + response;
          }

          if (response !== null) {
              try {
                  response = JSON.parse(response);
              }
              catch (error) {
                  throw 'Failed to parse response received from AWS CloudWatch API. Check debug log for more information.';
              }
          }

          return response;
      },

      getMetricsData: function () {
          var timestamp = new Date().getTime(),
              end_time = new Date(timestamp).toISOString().replace(/\.\d+Z/, 'Z'),
              start_time = new Date(timestamp - AwsEc2.request_period * 1000).toISOString().replace(/\.\d+Z/, 'Z'),
              payload = AwsEc2.prepareRecursive('MetricDataQueries', AwsEc2.renderPayload(AwsEc2.request_period, AwsEc2.params.instance_id));

          payload['Action'] = 'GetMetricData';
          payload['Version'] = '2010-08-01';
          payload['StartTime'] = start_time;
          payload['EndTime'] = end_time;
          payload['ScanBy'] = 'TimestampDescending';

          result = AwsEc2.request('GET', AwsEc2.params.region, 'monitoring', AwsEc2.prepareParams(payload));

          if (typeof result !== 'object'
                  || typeof result.GetMetricDataResponse !== 'object'
                  || typeof result.GetMetricDataResponse.GetMetricDataResult !== 'object'
                  || typeof result.GetMetricDataResponse.GetMetricDataResult.MetricDataResults !== 'object') {
              throw 'Cannot get metrics data from AWS CloudWatch API. Check debug log for more information.';
          }

          return result.GetMetricDataResponse.GetMetricDataResult.MetricDataResults;
      }
  };

  try {
      AwsEc2.setParams(JSON.parse(value));

      return JSON.stringify(AwsEc2.getMetricsData());
  }
  catch (error) {
      error += (String(error).endsWith('.')) ? '' : '.';
      Zabbix.log(3, '[ AWS EC2 ] ERROR: ' + error);

      return JSON.stringify({'error': error});
  }</params><description>Get instance metrics.
Full metrics list related to EC2: https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/viewing_metrics_with_cloudwatch.html</description><preprocessing><step><type>CHECK_NOT_SUPPORTED</type><parameters><parameter/></parameters></step></preprocessing><timeout>15s</timeout><parameters><parameter><name>access_key</name><value>{$AWS.ACCESS.KEY.ID}</value></parameter><parameter><name>secret_key</name><value>{$AWS.SECRET.ACCESS.KEY}</value></parameter><parameter><name>region</name><value>{$AWS.REGION}</value></parameter><parameter><name>instance_id</name><value>{$AWS.EC2.INSTANCE.ID}</value></parameter><parameter><name>proxy</name><value>{$AWS.PROXY}</value></parameter></parameters><tags><tag><tag>component</tag><value>raw</value></tag></tags></item><item><uuid>9ec4650b564c41bca9893eca279a8cc7</uuid><name>AWS EBS: Get volumes data</name><type>SCRIPT</type><key>aws.ec2.get_volumes</key><delay>5m</delay><history>0</history><trends>0</trends><value_type>TEXT</value_type><params>var AwsEbs = {
    params: {},
    request_period: 600,

    setParams: function (params) {
        ['access_key', 'secret_key', 'region', 'instance_id'].forEach(function (field) {
            if (typeof params !== 'object' || typeof params[field] === 'undefined' || params[field] === '') {
                throw 'Required param is not set: &quot;' + field + '&quot;.';
            }
        });

        AwsEbs.params = params;
    },

    sign: function (key, message) {
        var hex = hmac('sha256', key, message);

        if ((hex.length % 2) === 1) {
            throw 'Invalid length of a hex string!';
        }

        var result = new Int8Array(hex.length / 2);
        for (var i = 0, b = 0; i &lt; hex.length; i += 2, b++) {
            result[b] = parseInt(hex.substring(i, i + 2), 16);
        }

        return result;
    },

    prepareParams: function (params) {
        var result = [];

        Object.keys(params).sort().forEach(function (key) {
            if (typeof params[key] !== 'object') {
                result.push(key + '=' + encodeURIComponent(params[key]));
            }
            else {
                result.push(prepareObject(key, params[key]));
            }
        });

        return result.join('&amp;');
    },

    request: function (method, region, service, params, data) {
        if (typeof data === 'undefined' || data === null) {
            data = '';
        }

        var amzdate = (new Date()).toISOString().replace(/\.\d+Z/, 'Z').replace(/[-:]/g, ''),
            date = amzdate.replace(/T\d+Z/, ''),
            host = service + '.' + region + '.amazonaws.com',
            canonical_uri = '/',
            canonical_headers = 'content-encoding:amz-1.0\n' + 'host:' + host + '\n' + 'x-amz-date:' + amzdate + '\n',
            signed_headers = 'content-encoding;host;x-amz-date',
            canonical_request = method + '\n' + canonical_uri + '\n' + params + '\n' + canonical_headers + '\n' + signed_headers + '\n' + sha256(data),
            credential_scope = date + '/' + region + '/' + service + '/' + 'aws4_request',
            request_string = 'AWS4-HMAC-SHA256' + '\n' + amzdate + '\n' + credential_scope + '\n' + sha256(canonical_request),
            key = AwsEbs.sign('AWS4' + AwsEbs.params.secret_key, date);

        key = AwsEbs.sign(key, region);
        key = AwsEbs.sign(key, service);
        key = AwsEbs.sign(key, 'aws4_request');

        var request = new HttpRequest(),
            url = 'https://' + host + canonical_uri + '?' + params;

        if (typeof AwsEbs.params.proxy !== 'undefined' &amp;&amp; AwsEbs.params.proxy !== '') {
            request.setProxy(AwsEbs.params.proxy);
        }
        request.addHeader('x-amz-date: ' + amzdate);
        request.addHeader('Accept: application/json');
        request.addHeader('Content-Type: application/json');
        request.addHeader('Content-Encoding: amz-1.0');
        request.addHeader('Authorization: ' + 'AWS4-HMAC-SHA256 Credential=' + AwsEbs.params.access_key + '/' + credential_scope + ', ' + 'SignedHeaders=' + signed_headers + ', ' + 'Signature=' + hmac('sha256', key, request_string));

        Zabbix.log(4, '[ AWS EBS ] Sending request: ' + url);

        response = request.get(url);

        Zabbix.log(4, '[ AWS EBS ] Received response with status code ' + request.getStatus() + ': ' + response);

        if (request.getStatus() !== 200) {
            throw 'Request failed with status code ' + request.getStatus() + ': ' + response;
        }

        if (response !== null) {
            try {
                response = XML.toJson(response);
            }
            catch (error) {
                throw 'Failed to parse response received from AWS CloudWatch API. Check debug log for more information.';
            }
        }
        response = JSON.parse(response)

        return response;
    },


    getVolumesData: function () {
          var payload = {},
              volumes_list = [],
              result = [];

          payload['Action'] = 'DescribeVolumes',
              payload['MaxResults'] = 100,
              payload['Version'] = '2016-11-15',
              payload['Filter.1.Name'] = 'attachment.instance-id',
              payload['Filter.1.Value'] = AwsEbs.params.instance_id;

          while (payload.NextToken !== '') {
              var volumes = AwsEbs.request('GET', AwsEbs.params.region, 'ec2', AwsEbs.prepareParams(payload));
              if (typeof result !== 'object'
                  || typeof volumes.DescribeVolumesResponse !== 'object'
                  || typeof volumes.DescribeVolumesResponse.volumeSet !== 'object'
                  || typeof volumes.DescribeVolumesResponse.volumeSet.item !== 'object') {
                  throw 'Cannot get metrics data from AWS EC2 API. Check debug log for more information.';
              }
              payload.NextToken = volumes.DescribeVolumesResponse.NextToken || '';
              volumes_list = volumes.DescribeVolumesResponse.volumeSet.item

              if (typeof volumes_list === 'object'
                  &amp;&amp; volumes_list !== null
                  &amp;&amp; !Array.isArray(volumes_list)) {
                  volumes_list = [volumes_list];
              }

          }

          return volumes_list;
      }
  };

try {
    AwsEbs.setParams(JSON.parse(value));

    return JSON.stringify(AwsEbs.getVolumesData());
}
catch (error) {
    error += (String(error).endsWith('.')) ? '' : '.';
    Zabbix.log(3, '[ AWS EBS ] ERROR: ' + error);

    return JSON.stringify({ 'error': error });
}</params><description>Get volumes attached to instance.
DescribeVolumes API method: https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVolumes.html</description><preprocessing><step><type>CHECK_NOT_SUPPORTED</type><parameters><parameter/></parameters></step></preprocessing><timeout>15s</timeout><parameters><parameter><name>access_key</name><value>{$AWS.ACCESS.KEY.ID}</value></parameter><parameter><name>secret_key</name><value>{$AWS.SECRET.ACCESS.KEY}</value></parameter><parameter><name>region</name><value>{$AWS.REGION}</value></parameter><parameter><name>instance_id</name><value>{$AWS.EC2.INSTANCE.ID}</value></parameter><parameter><name>proxy</name><value>{$AWS.PROXY}</value></parameter></parameters><tags><tag><tag>component</tag><value>raw</value></tag></tags></item><item><uuid>adbe9cd98ffa41dda981c7f4e27a0d3b</uuid><name>AWS EC2: Metadata: No token</name><type>DEPENDENT</type><key>aws.ec2.metadata.no_token</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><description>The number of times the instance metadata service was successfully accessed using a method that does not use a token.
This metric is used to determine if there are any processes accessing instance metadata that are using Instance Metadata Service Version 1, which does not use a token.
If all requests use token-backed sessions, i.e., Instance Metadata Service Version 2, the value is 0.</description><preprocessing><step><type>JSONPATH</type><parameters><parameter>$.[?(@.Label == &quot;MetadataNoToken&quot;)].Values.first().first()</parameter></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>aws.ec2.get_metrics</key></master_item><tags><tag><tag>component</tag><value>metadata</value></tag></tags></item><item><uuid>7c264d8d5d934f898f7c745acd429d25</uuid><name>AWS EC2: Get metrics check</name><type>DEPENDENT</type><key>aws.ec2.metrics.check</key><delay>0</delay><history>7d</history><trends>0</trends><value_type>CHAR</value_type><description>Data collection check.</description><preprocessing><step><type>JSONPATH</type><parameters><parameter>$.error</parameter></parameters><error_handler>CUSTOM_VALUE</error_handler></step><step><type>DISCARD_UNCHANGED_HEARTBEAT</type><parameters><parameter>3h</parameter></parameters></step></preprocessing><master_item><key>aws.ec2.get_metrics</key></master_item><tags><tag><tag>component</tag><value>status</value></tag></tags><triggers><trigger><uuid>c2cf3f875aa14416a108dd05df7b053a</uuid><expression>length(last(/AWS EC2 by HTTP/aws.ec2.metrics.check))&gt;0</expression><name>AWS EC2: Failed to get metrics data</name><priority>WARNING</priority><tags><tag><tag>scope</tag><value>availability</value></tag></tags></trigger></triggers></item><item><uuid>2b16d3c6457842d892d06249a5fcd670</uuid><name>AWS EC2: Network: Bytes in, rate</name><type>DEPENDENT</type><key>aws.ec2.network_in.rate</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><units>Bps</units><description>The number of bytes received on all network interfaces by the instance.
This metric identifies the volume of incoming network traffic to a single instance.</description><preprocessing><step><type>JSONPATH</type><parameters><parameter>$.[?(@.Label == &quot;NetworkIn&quot;)].Values.first().first()</parameter></parameters><error_handler>DISCARD_VALUE</error_handler></step><step><type>JAVASCRIPT</type><parameters><parameter>return value / 300</parameter></parameters></step></preprocessing><master_item><key>aws.ec2.get_metrics</key></master_item><tags><tag><tag>component</tag><value>network</value></tag></tags></item><item><uuid>87fb8b61f115487696f02e50d98996ac</uuid><name>AWS EC2: Network: Bytes out, rate</name><type>DEPENDENT</type><key>aws.ec2.network_out.rate</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><units>Bps</units><description>The number of bytes sent out on all network interfaces by the instance. 
This metric identifies the volume of outgoing network traffic from a single instance.</description><preprocessing><step><type>JSONPATH</type><parameters><parameter>$.[?(@.Label == &quot;NetworkOut&quot;)].Values.first().first()</parameter></parameters></step><step><type>JAVASCRIPT</type><parameters><parameter>return value / 300</parameter></parameters></step></preprocessing><master_item><key>aws.ec2.get_metrics</key></master_item><tags><tag><tag>component</tag><value>network</value></tag></tags></item><item><uuid>a6b74493528b486782c4b73e080019e1</uuid><name>AWS EC2: Network: Packets in, rate</name><type>DEPENDENT</type><key>aws.ec2.packets_in.rate</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><description>The number of packets received on all network interfaces by the instance.
This metric identifies the volume of incoming traffic in terms of the number of packets on a single instance.
This metric is available for basic monitoring only.</description><preprocessing><step><type>JSONPATH</type><parameters><parameter>$.[?(@.Label == &quot;NetworkPacketsIn&quot;)].Values.first().first()</parameter></parameters><error_handler>DISCARD_VALUE</error_handler></step><step><type>JAVASCRIPT</type><parameters><parameter>return value / 300</parameter></parameters></step></preprocessing><master_item><key>aws.ec2.get_metrics</key></master_item><tags><tag><tag>component</tag><value>network</value></tag></tags></item><item><uuid>5d998e1680af4410b34fa9071bb7db78</uuid><name>AWS EC2: Network: Packets out, rate</name><type>DEPENDENT</type><key>aws.ec2.packets_out.rate</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><description>The number of packets sent out on all network interfaces by the instance.
This metric identifies the volume of outgoing traffic in terms of the number of packets on a single instance.
This metric is available for basic monitoring only.</description><preprocessing><step><type>JSONPATH</type><parameters><parameter>$.[?(@.Label == &quot;NetworkPacketsOut&quot;)].Values.first().first()</parameter></parameters><error_handler>DISCARD_VALUE</error_handler></step><step><type>JAVASCRIPT</type><parameters><parameter>return value / 300</parameter></parameters></step></preprocessing><master_item><key>aws.ec2.get_metrics</key></master_item><tags><tag><tag>component</tag><value>network</value></tag></tags></item><item><uuid>30156f76599147eaa5bcd4ca39816bbb</uuid><name>AWS EC2: Status: Check failed</name><type>DEPENDENT</type><key>aws.ec2.status_check_failed</key><delay>0</delay><history>7d</history><description>Reports whether the instance has passed both the instance status check and the system status check in the last minute.
This metric can be either 0 (passed) or 1 (failed).</description><valuemap><name>Status check</name></valuemap><preprocessing><step><type>JSONPATH</type><parameters><parameter>$.[?(@.Label == &quot;StatusCheckFailed&quot;)].Values.first().first()</parameter></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>aws.ec2.get_metrics</key></master_item><tags><tag><tag>component</tag><value>instance</value></tag></tags></item><item><uuid>b373f0994e784caf8f5f39da20d2f5c8</uuid><name>AWS EC2: Status: Check failed, instance</name><type>DEPENDENT</type><key>aws.ec2.status_check_failed_instance</key><delay>0</delay><history>7d</history><description>Reports whether the instance has passed the instance status check in the last minute.
This metric can be either 0 (passed) or 1 (failed).</description><valuemap><name>Status check</name></valuemap><preprocessing><step><type>JSONPATH</type><parameters><parameter>$.[?(@.Label == &quot;StatusCheckFailed_Instance&quot;)].Values.first().first()</parameter></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>aws.ec2.get_metrics</key></master_item><tags><tag><tag>component</tag><value>instance</value></tag></tags><triggers><trigger><uuid>0fdd6b02eea948d3a6c958af7f195dc3</uuid><expression>last(/AWS EC2 by HTTP/aws.ec2.status_check_failed_instance)=1</expression><name>AWS EC2: Instance status check failed</name><priority>AVERAGE</priority><description>These checks detect problems that require your involvement to repair.
The following are examples of problems that can cause instance status checks to fail:

Failed system status checks
Incorrect networking or startup configuration
Exhausted memory
Corrupted file system
Incompatible kernel</description><tags><tag><tag>scope</tag><value>availability</value></tag></tags></trigger></triggers></item><item><uuid>c7063824e3a74e6fa55ba21ecba35ca1</uuid><name>AWS EC2: Status: Check failed, system</name><type>DEPENDENT</type><key>aws.ec2.status_check_failed_system</key><delay>0</delay><history>7d</history><description>Reports whether the instance has passed the system status check in the last minute.
This metric can be either 0 (passed) or 1 (failed).</description><valuemap><name>Status check</name></valuemap><preprocessing><step><type>JSONPATH</type><parameters><parameter>$.[?(@.Label == &quot;StatusCheckFailed_System&quot;)].Values.first().first()</parameter></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>aws.ec2.get_metrics</key></master_item><tags><tag><tag>component</tag><value>instance</value></tag></tags><triggers><trigger><uuid>723a254ffd72404ea0cc2366ff186c1c</uuid><expression>last(/AWS EC2 by HTTP/aws.ec2.status_check_failed_system)=1</expression><name>AWS EC2: System status check failed</name><priority>AVERAGE</priority><description>These checks detect underlying problems with your instance that require AWS involvement to repair.
The following are examples of problems that can cause system status checks to fail:

Loss of network connectivity
Loss of system power
Software issues on the physical host
Hardware issues on the physical host that impact network reachability</description><tags><tag><tag>scope</tag><value>availability</value></tag></tags></trigger></triggers></item><item><uuid>3c819ed899c044ae8455266292f65632</uuid><name>AWS EC2: Get volumes info check</name><type>DEPENDENT</type><key>aws.ec2.volumes.check</key><delay>0</delay><history>7d</history><trends>0</trends><value_type>CHAR</value_type><description>Data collection check.</description><preprocessing><step><type>JSONPATH</type><parameters><parameter>$.error</parameter></parameters><error_handler>CUSTOM_VALUE</error_handler></step><step><type>DISCARD_UNCHANGED_HEARTBEAT</type><parameters><parameter>3h</parameter></parameters></step></preprocessing><master_item><key>aws.ec2.get_volumes</key></master_item><tags><tag><tag>component</tag><value>status</value></tag></tags><triggers><trigger><uuid>844fb22685804fe7894af7c64b420824</uuid><expression>length(last(/AWS EC2 by HTTP/aws.ec2.volumes.check))&gt;0</expression><name>AWS EC2: Failed to get volumes info</name><priority>WARNING</priority><tags><tag><tag>scope</tag><value>availability</value></tag></tags></trigger></triggers></item></items><discovery_rules><discovery_rule><uuid>318c50196d2b442e9b702f63e70c0820</uuid><name>Instance Alarms discovery</name><type>DEPENDENT</type><key>aws.ec2.alarms.discovery</key><delay>0</delay><filter><evaltype>AND</evaltype><conditions><condition><macro>{#ALARM_SERVICE_NAMESPACE}</macro><value>{$AWS.EC2.LLD.FILTER.ALARM_SERVICE_NAMESPACE.MATCHES}</value><formulaid>C</formulaid></condition><condition><macro>{#ALARM_SERVICE_NAMESPACE}</macro><value>{$AWS.EC2.LLD.FILTER.ALARM_SERVICE_NAMESPACE.NOT_MATCHES}</value><operator>NOT_MATCHES_REGEX</operator><formulaid>D</formulaid></condition><condition><macro>{#ALARM_NAME}</macro><value>{$AWS.EC2.LLD.FILTER.ALARM_NAME.MATCHES}</value><formulaid>A</formulaid></condition><condition><macro>{#ALARM_NAME}</macro><value>{$AWS.EC2.LLD.FILTER.ALARM_NAME.NOT_MATCHES}</value><operator>NOT_MATCHES_REGEX</operator><formulaid>B</formulaid></condition></conditions></filter><description>Discovery instance and attached EBS volumes alarms.</description><item_prototypes><item_prototype><uuid>87a163166aed40b786785b64122ab365</uuid><name>AWS EC2 Alarms: [&quot;{#ALARM_NAME}&quot;]: State</name><type>DEPENDENT</type><key>aws.ec2.alarm.state[&quot;{#ALARM_NAME}&quot;]</key><delay>0</delay><history>7d</history><description>The state value for the alarm. Possible values: 0 (OK), 1 (INSUFFICIENT_DATA), 2 (ALARM).
Alarm description:
{#ALARM_DESCRIPTION}</description><valuemap><name>Alarm state</name></valuemap><preprocessing><step><type>JSONPATH</type><parameters><parameter>$.[?(@.AlarmName == &quot;{#ALARM_NAME}&quot;)].StateValue.first()</parameter></parameters><error_handler>CUSTOM_VALUE</error_handler><error_handler_params>3</error_handler_params></step><step><type>JAVASCRIPT</type><parameters><parameter>var state = ['OK', 'INSUFFICIENT_DATA', 'ALARM'];

return state.indexOf(value.trim()) === -1 ? 255 : state.indexOf(value.trim());</parameter></parameters></step></preprocessing><master_item><key>aws.ec2.get_alarms</key></master_item><tags><tag><tag>component</tag><value>alarms</value></tag></tags><trigger_prototypes><trigger_prototype><uuid>be1301d97b5a47cc81dd6c2b76349f5d</uuid><expression>last(/AWS EC2 by HTTP/aws.ec2.alarm.state[&quot;{#ALARM_NAME}&quot;])=1</expression><name>AWS EC2 Alarms: &quot;{#ALARM_NAME}&quot; has 'Insufficient data' state</name><priority>INFO</priority><tags><tag><tag>scope</tag><value>notice</value></tag></tags></trigger_prototype></trigger_prototypes></item_prototype><item_prototype><uuid>92a33b49f010464db7e6c7ef586240e9</uuid><name>AWS EC2 Alarms: [&quot;{#ALARM_NAME}&quot;]: State reason</name><type>DEPENDENT</type><key>aws.ec2.alarm.state_reason[&quot;{#ALARM_NAME}&quot;]</key><delay>0</delay><history>7d</history><trends>0</trends><value_type>TEXT</value_type><description>An explanation for the alarm state, in text format.
Alarm description:
{#ALARM_DESCRIPTION}</description><preprocessing><step><type>JSONPATH</type><parameters><parameter>$.[?(@.AlarmName == &quot;{#ALARM_NAME}&quot;)].StateReason.first()</parameter></parameters><error_handler>DISCARD_VALUE</error_handler></step><step><type>DISCARD_UNCHANGED_HEARTBEAT</type><parameters><parameter>3h</parameter></parameters></step></preprocessing><master_item><key>aws.ec2.get_alarms</key></master_item><tags><tag><tag>component</tag><value>alarms</value></tag></tags></item_prototype></item_prototypes><trigger_prototypes><trigger_prototype><uuid>93813bd6aaf14fcb84068cb2c2e5d47e</uuid><expression>last(/AWS EC2 by HTTP/aws.ec2.alarm.state[&quot;{#ALARM_NAME}&quot;])=2 and length(last(/AWS EC2 by HTTP/aws.ec2.alarm.state_reason[&quot;{#ALARM_NAME}&quot;]))&gt;0</expression><name>AWS EC2 Alarms: &quot;{#ALARM_NAME}&quot; has 'Alarm' state</name><priority>AVERAGE</priority><description>Alarm &quot;{#ALARM_NAME}&quot; has 'Alarm' state. 
Reason: {ITEM.LASTVALUE2}</description><tags><tag><tag>scope</tag><value>availability</value></tag></tags></trigger_prototype></trigger_prototypes><master_item><key>aws.ec2.get_alarms</key></master_item><preprocessing><step><type>JAVASCRIPT</type><parameters><parameter>var result = [];
var alarms = JSON.parse(value);

alarms.forEach(function(alarm) {

 result.push({
'{#ALARM_DESCRIPTION}': alarm.AlarmDescription !== null ? alarm.AlarmDescription : 'None' ,
'{#ALARM_NAME}': alarm.AlarmName,
'{#ALARM_PERIOD}': alarm.Period,
'{#METRIC_NAME}': alarm.MetricName,
'{#ALARM_SERVICE_NAMESPACE}': alarm.Namespace !== null ? alarm.Namespace : 'None'
  });
});

return JSON.stringify(result);</parameter></parameters></step><step><type>DISCARD_UNCHANGED_HEARTBEAT</type><parameters><parameter>3h</parameter></parameters></step></preprocessing></discovery_rule><discovery_rule><uuid>6cf7fc98fea44b0789a5aaa837042699</uuid><name>Instance Volumes discovery</name><type>DEPENDENT</type><key>aws.ec2.volumes.discovery</key><delay>0</delay><filter><evaltype>AND</evaltype><conditions><condition><macro>{#VOLUME_TYPE}</macro><value>{$AWS.EC2.LLD.FILTER.VOLUME_TYPE.MATCHES}</value><formulaid>A</formulaid></condition><condition><macro>{#VOLUME_TYPE}</macro><value>{$AWS.EC2.LLD.FILTER.VOLUME_TYPE.NOT_MATCHES}</value><operator>NOT_MATCHES_REGEX</operator><formulaid>B</formulaid></condition></conditions></filter><description>Discovery attached EBS volumes.</description><item_prototypes><item_prototype><uuid>cc0ece769d954bb590fb1a1a3d20e559</uuid><name>AWS EBS: [&quot;{#VOLUME_ID}&quot;]: Attachment state</name><type>DEPENDENT</type><key>aws.ec2.ebs.attachment_status[&quot;{#VOLUME_ID}&quot;]</key><delay>0</delay><history>7d</history><description>The attachment state of the volume. Possible values: 0 (attaching), 1 (attached), 2 (detaching).</description><valuemap><name>Volume attachment state</name></valuemap><preprocessing><step><type>JSONPATH</type><parameters><parameter>$.[?(@.volumeId == &quot;{#VOLUME_ID}&quot;)].attachmentSet..[?(@.instanceId == &quot;{$AWS.EC2.INSTANCE.ID}&quot;)].status.first()</parameter></parameters><error_handler>DISCARD_VALUE</error_handler></step><step><type>JAVASCRIPT</type><parameters><parameter>var state = ['attaching', 'attached', 'detaching'];

return state.indexOf(value.trim()) === -1 ? 255 : state.indexOf(value.trim());</parameter></parameters></step><step><type>DISCARD_UNCHANGED_HEARTBEAT</type><parameters><parameter>3h</parameter></parameters></step></preprocessing><master_item><key>aws.ec2.get_volumes</key></master_item><tags><tag><tag>component</tag><value>volumes</value></tag><tag><tag>type</tag><value>{#VOLUME_TYPE}</value></tag><tag><tag>volume</tag><value>{#VOLUME_ID}</value></tag></tags></item_prototype><item_prototype><uuid>639e7ddcac6345239fa27549ad35e799</uuid><name>AWS EBS: [&quot;{#VOLUME_ID}&quot;]: Attachment time</name><type>DEPENDENT</type><key>aws.ec2.ebs.attachment_time[&quot;{#VOLUME_ID}&quot;]</key><delay>0</delay><history>7d</history><trends>0</trends><value_type>CHAR</value_type><description>The time stamp when the attachment initiated.</description><valuemap><name>Volume attachment state</name></valuemap><preprocessing><step><type>JSONPATH</type><parameters><parameter>$.[?(@.volumeId == &quot;{#VOLUME_ID}&quot;)].attachmentSet..[?(@.instanceId == &quot;{$AWS.EC2.INSTANCE.ID}&quot;)].attachTime.first()</parameter></parameters><error_handler>DISCARD_VALUE</error_handler></step><step><type>DISCARD_UNCHANGED_HEARTBEAT</type><parameters><parameter>3h</parameter></parameters></step></preprocessing><master_item><key>aws.ec2.get_volumes</key></master_item><tags><tag><tag>component</tag><value>volumes</value></tag><tag><tag>type</tag><value>{#VOLUME_TYPE}</value></tag><tag><tag>volume</tag><value>{#VOLUME_ID}</value></tag></tags></item_prototype><item_prototype><uuid>2df96e6c726e40c6a257c00ae26e8902</uuid><name>AWS EBS: [&quot;{#VOLUME_ID}&quot;]: Create time</name><type>DEPENDENT</type><key>aws.ec2.ebs.create_time[&quot;{#VOLUME_ID}&quot;]</key><delay>0</delay><history>7d</history><trends>0</trends><value_type>CHAR</value_type><description>The time stamp when volume creation was initiated.</description><preprocessing><step><type>JSONPATH</type><parameters><parameter>$.[?(@.volumeId == &quot;{#VOLUME_ID}&quot;)].createTime.first()</parameter></parameters><error_handler>DISCARD_VALUE</error_handler></step><step><type>DISCARD_UNCHANGED_HEARTBEAT</type><parameters><parameter>3h</parameter></parameters></step></preprocessing><master_item><key>aws.ec2.get_volumes</key></master_item><tags><tag><tag>component</tag><value>volumes</value></tag><tag><tag>type</tag><value>{#VOLUME_TYPE}</value></tag><tag><tag>volume</tag><value>{#VOLUME_ID}</value></tag></tags></item_prototype><item_prototype><uuid>141205eac3e4437d824794f8e6c76e90</uuid><name>AWS EBS: [&quot;{#VOLUME_ID}&quot;]: Device</name><type>DEPENDENT</type><key>aws.ec2.ebs.device[&quot;{#VOLUME_ID}&quot;]</key><delay>0</delay><history>7d</history><trends>0</trends><value_type>CHAR</value_type><description>The device name specified in the block device mapping (for example, /dev/sda1).</description><preprocessing><step><type>JSONPATH</type><parameters><parameter>$.[?(@.volumeId == &quot;{#VOLUME_ID}&quot;)].attachmentSet..[?(@.instanceId == &quot;{$AWS.EC2.INSTANCE.ID}&quot;)].device.first()</parameter></parameters><error_handler>DISCARD_VALUE</error_handler></step><step><type>DISCARD_UNCHANGED_HEARTBEAT</type><parameters><parameter>3h</parameter></parameters></step></preprocessing><master_item><key>aws.ec2.get_volumes</key></master_item><tags><tag><tag>component</tag><value>volumes</value></tag><tag><tag>type</tag><value>{#VOLUME_TYPE}</value></tag><tag><tag>volume</tag><value>{#VOLUME_ID}</value></tag></tags></item_prototype><item_prototype><uuid>95add92252e24ab8b596c539d8090f3d</uuid><name>AWS EBS: [&quot;{#VOLUME_ID}&quot;]: Status</name><type>DEPENDENT</type><key>aws.ec2.ebs.status[&quot;{#VOLUME_ID}&quot;]</key><delay>0</delay><history>7d</history><description>The state of the volume.
Possible values: 0 (creating), 1 (available), 2 (in-use), 3 (deleting), 4 (deleted), 5 (error).</description><valuemap><name>Volume status</name></valuemap><preprocessing><step><type>JSONPATH</type><parameters><parameter>$.[?(@.volumeId == &quot;{#VOLUME_ID}&quot;)].status.first()</parameter></parameters><error_handler>DISCARD_VALUE</error_handler></step><step><type>JAVASCRIPT</type><parameters><parameter>var state = ['creating', 'available', 'in-use', 'deleting', 'deleted', 'error'];

return state.indexOf(value.trim()) === -1 ? 255 : state.indexOf(value.trim());</parameter></parameters></step><step><type>DISCARD_UNCHANGED_HEARTBEAT</type><parameters><parameter>3h</parameter></parameters></step></preprocessing><master_item><key>aws.ec2.get_volumes</key></master_item><tags><tag><tag>component</tag><value>volumes</value></tag><tag><tag>type</tag><value>{#VOLUME_TYPE}</value></tag><tag><tag>volume</tag><value>{#VOLUME_ID}</value></tag></tags><trigger_prototypes><trigger_prototype><uuid>2d4de438bdaa49b2930496ce6ddbe52d</uuid><expression>last(/AWS EC2 by HTTP/aws.ec2.ebs.status[&quot;{#VOLUME_ID}&quot;])=5</expression><name>AWS EBS: Volume &quot;{#VOLUME_ID}&quot; has 'error' state</name><priority>WARNING</priority><tags><tag><tag>scope</tag><value>availability</value></tag></tags></trigger_prototype></trigger_prototypes></item_prototype><item_prototype><uuid>fd10966f674e430a9dd70b148dcfa002</uuid><name>AWS EBS: [&quot;{#VOLUME_ID}&quot;]: Burst balance</name><type>DEPENDENT</type><key>aws.ec2.ebs.volume.burst_balance[&quot;{#VOLUME_ID}&quot;]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><units>%</units><description>Used with General Purpose SSD (gp2), Throughput Optimized HDD (st1), and Cold HDD (sc1) volumes only.
Provides information about the percentage of I/O credits (for gp2) or throughput credits (for st1 and sc1) remaining in the burst bucket. 
Data is reported to CloudWatch only when the volume is active. If the volume is not attached, no data is reported.</description><preprocessing><step><type>JSONPATH</type><parameters><parameter>$.[?(@.Label == &quot;BurstBalance&quot;)].Values.first().first()</parameter></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>aws.ec2.get_ebs_metrics[&quot;{#VOLUME_ID}&quot;]</key></master_item><tags><tag><tag>component</tag><value>volumes</value></tag><tag><tag>type</tag><value>{#VOLUME_TYPE}</value></tag><tag><tag>volume</tag><value>{#VOLUME_ID}</value></tag></tags><trigger_prototypes><trigger_prototype><uuid>9b2f5687020c4a5987c1b1b35a57d8b9</uuid><expression>max(/AWS EC2 by HTTP/aws.ec2.ebs.volume.burst_balance[&quot;{#VOLUME_ID}&quot;],5m)&lt;{$AWS.EBS.BURST.CREDIT.BALANCE.MIN.WARN}</expression><name>AWS EBS: Burst balance is too low</name><event_name>AWS EBS: Burst balance is too low (less {$AWS.EBS.BURST.CREDIT.BALANCE.MIN.WARN}% for 5m)</event_name><opdata>Current value: {ITEM.LASTVALUE1}</opdata><priority>WARNING</priority><tags><tag><tag>scope</tag><value>capacity</value></tag></tags></trigger_prototype></trigger_prototypes></item_prototype><item_prototype><uuid>8b936cef38294799a6826764eae68850</uuid><name>AWS EBS: [&quot;{#VOLUME_ID}&quot;]: Consumed Read/Write, ops</name><type>DEPENDENT</type><key>aws.ec2.ebs.volume.consumed_read_write_ops[&quot;{#VOLUME_ID}&quot;]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><description>Used with Provisioned IOPS SSD volumes only.
The total amount of read and write operations (normalized to 256K capacity units) consumed in a specified period of time.
I/O operations that are smaller than 256K each count as 1 consumed IOPS. I/O operations that are larger than 256K are counted in 256K capacity units. 
For example, a 1024K I/O would count as 4 consumed IOPS.</description><preprocessing><step><type>JSONPATH</type><parameters><parameter>$.[?(@.Label == &quot;VolumeConsumedReadWriteOps&quot;)].Values.first().first()</parameter></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>aws.ec2.get_ebs_metrics[&quot;{#VOLUME_ID}&quot;]</key></master_item><tags><tag><tag>component</tag><value>volumes</value></tag><tag><tag>type</tag><value>{#VOLUME_TYPE}</value></tag><tag><tag>volume</tag><value>{#VOLUME_ID}</value></tag></tags></item_prototype><item_prototype><uuid>5476d32c036d49588238cb2d2a4d652f</uuid><name>AWS EBS: [&quot;{#VOLUME_ID}&quot;]: Idle time</name><type>DEPENDENT</type><key>aws.ec2.ebs.volume.idle_time[&quot;{#VOLUME_ID}&quot;]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><units>s</units><description>This metric is not supported with Multi-Attach enabled volumes.
The total number of seconds in a specified period of time when no read or write operations were submitted.</description><preprocessing><step><type>JSONPATH</type><parameters><parameter>$.[?(@.Label == &quot;VolumeIdleTime&quot;)].Values.first().first()</parameter></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>aws.ec2.get_ebs_metrics[&quot;{#VOLUME_ID}&quot;]</key></master_item><tags><tag><tag>component</tag><value>volumes</value></tag><tag><tag>type</tag><value>{#VOLUME_TYPE}</value></tag><tag><tag>volume</tag><value>{#VOLUME_ID}</value></tag></tags></item_prototype><item_prototype><uuid>4dbb00e53cd84b9f88c44c765e73bd85</uuid><name>AWS EBS: [&quot;{#VOLUME_ID}&quot;]: Queue length</name><type>DEPENDENT</type><key>aws.ec2.ebs.volume.queue_length[&quot;{#VOLUME_ID}&quot;]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><description>The number of read and write operation requests waiting to be completed in a specified period of time.</description><preprocessing><step><type>JSONPATH</type><parameters><parameter>$.[?(@.Label == &quot;VolumeQueueLength&quot;)].Values.first().first()</parameter></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>aws.ec2.get_ebs_metrics[&quot;{#VOLUME_ID}&quot;]</key></master_item><tags><tag><tag>component</tag><value>volumes</value></tag><tag><tag>type</tag><value>{#VOLUME_TYPE}</value></tag><tag><tag>volume</tag><value>{#VOLUME_ID}</value></tag></tags></item_prototype><item_prototype><uuid>7313a503be27469ea82733ed965b57e4</uuid><name>AWS EBS: [&quot;{#VOLUME_ID}&quot;]: Read, bytes</name><type>DEPENDENT</type><key>aws.ec2.ebs.volume.read_bytes[&quot;{#VOLUME_ID}&quot;]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><units>Bps</units><description>Provides information on the read operations in a specified period of time.
The average size of each read operation during the period, except on volumes attached to a Nitro-based instance, where the average represents the average over the specified period.
For Xen instances, data is reported only when there is read activity on the volume.</description><preprocessing><step><type>JSONPATH</type><parameters><parameter>$.[?(@.Label == &quot;VolumeReadBytes&quot;)].Values.first().first()</parameter></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>aws.ec2.get_ebs_metrics[&quot;{#VOLUME_ID}&quot;]</key></master_item><tags><tag><tag>component</tag><value>volumes</value></tag><tag><tag>type</tag><value>{#VOLUME_TYPE}</value></tag><tag><tag>volume</tag><value>{#VOLUME_ID}</value></tag></tags></item_prototype><item_prototype><uuid>13d3dce70956402c945421c87e8eb784</uuid><name>AWS EBS: [&quot;{#VOLUME_ID}&quot;]: Read, ops</name><type>DEPENDENT</type><key>aws.ec2.ebs.volume.read_ops[&quot;{#VOLUME_ID}&quot;]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><units>Ops</units><description>The total number of read operations in a specified period of time. Note: read operations are counted on completion.</description><preprocessing><step><type>JSONPATH</type><parameters><parameter>$.[?(@.Label == &quot;VolumeReadOps&quot;)].Values.first().first()</parameter></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>aws.ec2.get_ebs_metrics[&quot;{#VOLUME_ID}&quot;]</key></master_item><tags><tag><tag>component</tag><value>volumes</value></tag><tag><tag>type</tag><value>{#VOLUME_TYPE}</value></tag><tag><tag>volume</tag><value>{#VOLUME_ID}</value></tag></tags></item_prototype><item_prototype><uuid>8d0b610ac0e3479a921720ef623ef896</uuid><name>AWS EBS: [&quot;{#VOLUME_ID}&quot;]: Throughput, pct</name><type>DEPENDENT</type><key>aws.ec2.ebs.volume.throughput_percentage[&quot;{#VOLUME_ID}&quot;]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><units>%</units><description>This metric is not supported with Multi-Attach enabled volumes.
Used with Provisioned IOPS SSD volumes only. The percentage of I/O operations per second (IOPS) delivered of the total IOPS provisioned for an Amazon EBS volume.
Provisioned IOPS SSD volumes deliver their provisioned performance 99.9 percent of the time.
During a write, if there are no other pending I/O requests in a minute, the metric value will be 100 percent.
Also, a volume's I/O performance may become degraded temporarily due to an action you have taken (for example, creating a snapshot of a volume during peak usage, running the volume on a non-EBS-optimized instance, or accessing data on the volume for the first time).</description><preprocessing><step><type>JSONPATH</type><parameters><parameter>$.[?(@.Label == &quot;VolumeThroughputPercentage&quot;)].Values.first().first()</parameter></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>aws.ec2.get_ebs_metrics[&quot;{#VOLUME_ID}&quot;]</key></master_item><tags><tag><tag>component</tag><value>volumes</value></tag><tag><tag>type</tag><value>{#VOLUME_TYPE}</value></tag><tag><tag>volume</tag><value>{#VOLUME_ID}</value></tag></tags></item_prototype><item_prototype><uuid>58163c98e1b943ceae5fcb52ff85dcfd</uuid><name>AWS EBS: [&quot;{#VOLUME_ID}&quot;]: Read time, total</name><type>DEPENDENT</type><key>aws.ec2.ebs.volume.total_read_time[&quot;{#VOLUME_ID}&quot;]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><units>s</units><description>This metric is not supported with Multi-Attach enabled volumes.
The total number of seconds spent by all read operations that completed in a specified period of time.
If multiple requests are submitted at the same time, this total could be greater than the length of the period. 
For example, for a period of 1 minutes (60 seconds): if 150 operations completed during that period, and each operation took 1 second, the value would be 150 seconds. 
For Xen instances, data is reported only when there is read activity on the volume.</description><preprocessing><step><type>JSONPATH</type><parameters><parameter>$.[?(@.Label == &quot;VolumeTotalReadTime&quot;)].Values.first().first()</parameter></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>aws.ec2.get_ebs_metrics[&quot;{#VOLUME_ID}&quot;]</key></master_item><tags><tag><tag>component</tag><value>volumes</value></tag><tag><tag>type</tag><value>{#VOLUME_TYPE}</value></tag><tag><tag>volume</tag><value>{#VOLUME_ID}</value></tag></tags></item_prototype><item_prototype><uuid>264a8f7df9e64d219082d5239b90cdf3</uuid><name>AWS EBS: [&quot;{#VOLUME_ID}&quot;]: Write time, total</name><type>DEPENDENT</type><key>aws.ec2.ebs.volume.total_write_time[&quot;{#VOLUME_ID}&quot;]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><units>s</units><description>This metric is not supported with Multi-Attach enabled volumes.
The total number of seconds spent by all write operations that completed in a specified period of time.
If multiple requests are submitted at the same time, this total could be greater than the length of the period.
For example, for a period of 1 minute (60 seconds): if 150 operations completed during that period, and each operation took 1 second, the value would be 150 seconds. 
For Xen instances, data is reported only when there is write activity on the volume.</description><preprocessing><step><type>JSONPATH</type><parameters><parameter>$.[?(@.Label == &quot;VolumeTotalWriteTime&quot;)].Values.first().first()</parameter></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>aws.ec2.get_ebs_metrics[&quot;{#VOLUME_ID}&quot;]</key></master_item><tags><tag><tag>component</tag><value>volumes</value></tag><tag><tag>type</tag><value>{#VOLUME_TYPE}</value></tag><tag><tag>volume</tag><value>{#VOLUME_ID}</value></tag></tags></item_prototype><item_prototype><uuid>459900740e784ca9ba7a8baf5b95734e</uuid><name>AWS EBS: [&quot;{#VOLUME_ID}&quot;]: Write, bytes</name><type>DEPENDENT</type><key>aws.ec2.ebs.volume.write_bytes[&quot;{#VOLUME_ID}&quot;]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><units>Bps</units><description>Provides information on the write operations in a specified period of time.
The average size of each write operation during the period, except on volumes attached to a Nitro-based instance, where the average represents the average over the specified period.
For Xen instances, data is reported only when there is write activity on the volume.</description><preprocessing><step><type>JSONPATH</type><parameters><parameter>$.[?(@.Label == &quot;VolumeWriteBytes&quot;)].Values.first().first()</parameter></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>aws.ec2.get_ebs_metrics[&quot;{#VOLUME_ID}&quot;]</key></master_item><tags><tag><tag>component</tag><value>volumes</value></tag><tag><tag>type</tag><value>{#VOLUME_TYPE}</value></tag><tag><tag>volume</tag><value>{#VOLUME_ID}</value></tag></tags></item_prototype><item_prototype><uuid>7216494987dc45f59fc3a4b9100e4159</uuid><name>AWS EBS: [&quot;{#VOLUME_ID}&quot;]: Write, ops</name><type>DEPENDENT</type><key>aws.ec2.ebs.volume.write_ops[&quot;{#VOLUME_ID}&quot;]</key><delay>0</delay><history>7d</history><value_type>FLOAT</value_type><units>Ops</units><description>The total number of write operations in a specified period of time. Note: write operations are counted on completion.</description><preprocessing><step><type>JSONPATH</type><parameters><parameter>$.[?(@.Label == &quot;VolumeWriteOps&quot;)].Values.first().first()</parameter></parameters><error_handler>DISCARD_VALUE</error_handler></step></preprocessing><master_item><key>aws.ec2.get_ebs_metrics[&quot;{#VOLUME_ID}&quot;]</key></master_item><tags><tag><tag>component</tag><value>volumes</value></tag><tag><tag>type</tag><value>{#VOLUME_TYPE}</value></tag><tag><tag>volume</tag><value>{#VOLUME_ID}</value></tag></tags></item_prototype><item_prototype><uuid>8b3b008f7f65408fbd49e46186b01cfb</uuid><name>AWS EBS: [&quot;{#VOLUME_ID}&quot;]: Get metrics</name><type>SCRIPT</type><key>aws.ec2.get_ebs_metrics[&quot;{#VOLUME_ID}&quot;]</key><delay>0s;m/5</delay><history>0</history><trends>0</trends><value_type>TEXT</value_type><params>var AwsEbs = {
    params: {},
    request_period: 600,

    setParams: function (params) {
        ['access_key', 'secret_key', 'region', 'volume_id'].forEach(function (field) {
            if (typeof params !== 'object' || typeof params[field] === 'undefined' || params[field] === '') {
                throw 'Required param is not set: &quot;' + field + '&quot;.';
            }
        });

        AwsEbs.params = params;
    },

    sign: function (key, message) {
        var hex = hmac('sha256', key, message);

        if ((hex.length % 2) === 1) {
            throw 'Invalid length of a hex string!';
        }

        var result = new Int8Array(hex.length / 2);
        for (var i = 0, b = 0; i &lt; hex.length; i += 2, b++) {
            result[b] = parseInt(hex.substring(i, i + 2), 16);
        }

        return result;
    },

    prepareRecursive: function (prefix, param) {
        var result = {};

        if (typeof param === 'object') {
            if (Array.isArray(param)) {
                param.forEach(function (value, index) {
                    var nested = AwsEbs.prepareRecursive(prefix + '.member.' + (index + 1), value);
                    Object.keys(nested).forEach(function (key) {
                        result[key] = nested[key];
                    });
                });
            }
            else {
                Object.keys(param).forEach(function (k) {
                    var nested = AwsEbs.prepareRecursive(prefix + '.' + k, param[k]);
                    Object.keys(nested).forEach(function (key) {
                        result[key] = nested[key];
                    });
                });
            }
        }
        else {
            result[prefix] = param;
        }

        return result;
    },

    renderPayload: function (period, volume_id) {
        var metrics_list = [
            'VolumeReadBytes:Bytes',
            'VolumeWriteBytes:Bytes',
            'VolumeReadOps:Count',
            'VolumeWriteOps:Count',
            'VolumeTotalReadTime:Seconds',
            'VolumeTotalWriteTime:Seconds',
            'VolumeIdleTime:Seconds',
            'VolumeQueueLength:Count',
            'VolumeThroughputPercentage:Percent',
            'VolumeConsumedReadWriteOps:Count',
            'BurstBalance:Percent'
        ];

        var metric_payload = [];
        metrics_list.forEach(function (metric) {
            var parts = metric.split(':', 2);
            var name = parts[0].replace(/[^a-zA-Z0-9]/g, '');
            metric_payload.push({
                'Id': name.charAt(0).toLowerCase() + name.slice(1),
                'MetricStat': {
                    'Metric': {
                        'MetricName': parts[0],
                        'Namespace': 'AWS/EBS',
                        'Dimensions': [
                            {
                                'Name': 'VolumeId',
                                'Value': volume_id
                            }
                        ]
                    },
                    'Period': period,
                    'Stat': 'Average',
                    'Unit': parts[1]
                }
            });
        });

        return metric_payload;
    },

    prepareParams: function (params) {
        var result = [];

        Object.keys(params).sort().forEach(function (key) {
            if (typeof params[key] !== 'object') {
                result.push(key + '=' + encodeURIComponent(params[key]));
            }
            else {
                result.push(prepareObject(key, params[key]));
            }
        });

        return result.join('&amp;');
    },

    request: function (method, region, service, params, data) {
        if (typeof data === 'undefined' || data === null) {
            data = '';
        }

        var amzdate = (new Date()).toISOString().replace(/\.\d+Z/, 'Z').replace(/[-:]/g, ''),
            date = amzdate.replace(/T\d+Z/, ''),
            host = service + '.' + region + '.amazonaws.com',
            canonical_uri = '/',
            canonical_headers = 'content-encoding:amz-1.0\n' + 'host:' + host + '\n' + 'x-amz-date:' + amzdate + '\n',
            signed_headers = 'content-encoding;host;x-amz-date',
            canonical_request = method + '\n' + canonical_uri + '\n' + params + '\n' + canonical_headers + '\n' + signed_headers + '\n' + sha256(data),
            credential_scope = date + '/' + region + '/' + service + '/' + 'aws4_request',
            request_string = 'AWS4-HMAC-SHA256' + '\n' + amzdate + '\n' + credential_scope + '\n' + sha256(canonical_request),
            key = AwsEbs.sign('AWS4' + AwsEbs.params.secret_key, date);

        key = AwsEbs.sign(key, region);
        key = AwsEbs.sign(key, service);
        key = AwsEbs.sign(key, 'aws4_request');

        var request = new HttpRequest(),
            url = 'https://' + host + canonical_uri + '?' + params;

        if (typeof AwsEbs.params.proxy !== 'undefined' &amp;&amp; AwsEbs.params.proxy !== '') {
            request.setProxy(AwsEbs.params.proxy);
        }
        request.addHeader('x-amz-date: ' + amzdate);
        request.addHeader('Accept: application/json');
        request.addHeader('Content-Type: application/json');
        request.addHeader('Content-Encoding: amz-1.0');
        request.addHeader('Authorization: ' + 'AWS4-HMAC-SHA256 Credential=' + AwsEbs.params.access_key + '/' + credential_scope + ', ' + 'SignedHeaders=' + signed_headers + ', ' + 'Signature=' + hmac('sha256', key, request_string));

        Zabbix.log(4, '[ AWS EBS ] Sending request: ' + url);

        response = request.get(url);

        Zabbix.log(4, '[ AWS EBS ] Received response with status code ' + request.getStatus() + ': ' + response);

        if (request.getStatus() !== 200) {
            throw 'Request failed with status code ' + request.getStatus() + ': ' + response;
        }

        if (response !== null) {
            try {
                response = JSON.parse(response);
            }
            catch (error) {
                throw 'Failed to parse response received from AWS CloudWatch API. Check debug log for more information.';
            }
        }

        return response;
    },

    getMetricsData: function () {
        var timestamp = new Date().getTime(),
            end_time = new Date(timestamp).toISOString().replace(/\.\d+Z/, 'Z'),
            start_time = new Date(timestamp - AwsEbs.request_period * 1000).toISOString().replace(/\.\d+Z/, 'Z'),
            payload = AwsEbs.prepareRecursive('MetricDataQueries', AwsEbs.renderPayload(AwsEbs.request_period, AwsEbs.params.volume_id));

        payload['Action'] = 'GetMetricData';
        payload['Version'] = '2010-08-01';
        payload['StartTime'] = start_time;
        payload['EndTime'] = end_time;
        payload['ScanBy'] = 'TimestampDescending';

        result = AwsEbs.request('GET', AwsEbs.params.region, 'monitoring', AwsEbs.prepareParams(payload));

        if (typeof result !== 'object'
                || typeof result.GetMetricDataResponse !== 'object'
                || typeof result.GetMetricDataResponse.GetMetricDataResult !== 'object'
                || typeof result.GetMetricDataResponse.GetMetricDataResult.MetricDataResults !== 'object') {
            throw 'Cannot get metrics data from AWS CloudWatch API. Check debug log for more information.';
        }

        return result.GetMetricDataResponse.GetMetricDataResult.MetricDataResults;
    }
};

try {
    AwsEbs.setParams(JSON.parse(value));

    return JSON.stringify(AwsEbs.getMetricsData());
}
catch (error) {
    error += (String(error).endsWith('.')) ? '' : '.';
    Zabbix.log(3, '[ AWS EBS ] ERROR: ' + error);

    return JSON.stringify({'error': error});
}</params><description>Get metrics of EBS volume.
Full metrics list related to EBS: https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using_cloudwatch_ebs.html</description><preprocessing><step><type>CHECK_NOT_SUPPORTED</type><parameters><parameter/></parameters></step></preprocessing><timeout>15s</timeout><parameters><parameter><name>access_key</name><value>{$AWS.ACCESS.KEY.ID}</value></parameter><parameter><name>secret_key</name><value>{$AWS.SECRET.ACCESS.KEY}</value></parameter><parameter><name>region</name><value>{$AWS.REGION}</value></parameter><parameter><name>volume_id</name><value>{#VOLUME_ID}</value></parameter><parameter><name>proxy</name><value>{$AWS.PROXY}</value></parameter></parameters><tags><tag><tag>component</tag><value>raw</value></tag><tag><tag>type</tag><value>{#VOLUME_TYPE}</value></tag><tag><tag>volume</tag><value>{#VOLUME_ID}</value></tag></tags></item_prototype></item_prototypes><graph_prototypes><graph_prototype><uuid>dbf87c66b9034e1ab40f3a2d4adb1a5a</uuid><name>AWS EBS: [&quot;{#VOLUME_ID}&quot;]: Volume read/write bytes</name><graph_items><graph_item><color>1A7C11</color><item><host>AWS EC2 by HTTP</host><key>aws.ec2.ebs.volume.write_bytes[&quot;{#VOLUME_ID}&quot;]</key></item></graph_item><graph_item><sortorder>1</sortorder><color>2774A4</color><item><host>AWS EC2 by HTTP</host><key>aws.ec2.ebs.volume.read_bytes[&quot;{#VOLUME_ID}&quot;]</key></item></graph_item></graph_items></graph_prototype><graph_prototype><uuid>97faf8177efd46f2b90a7078e532f623</uuid><name>AWS EBS: [&quot;{#VOLUME_ID}&quot;]: Volume read/write ops</name><graph_items><graph_item><color>1A7C11</color><item><host>AWS EC2 by HTTP</host><key>aws.ec2.ebs.volume.write_ops[&quot;{#VOLUME_ID}&quot;]</key></item></graph_item><graph_item><sortorder>1</sortorder><color>2774A4</color><item><host>AWS EC2 by HTTP</host><key>aws.ec2.ebs.volume.read_ops[&quot;{#VOLUME_ID}&quot;]</key></item></graph_item></graph_items></graph_prototype><graph_prototype><uuid>c27e794ff80a4335874ae9b58c8ce6b8</uuid><name>AWS EBS: [&quot;{#VOLUME_ID}&quot;]: Volume read/write time</name><graph_items><graph_item><color>1A7C11</color><item><host>AWS EC2 by HTTP</host><key>aws.ec2.ebs.volume.total_write_time[&quot;{#VOLUME_ID}&quot;]</key></item></graph_item><graph_item><sortorder>1</sortorder><color>2774A4</color><item><host>AWS EC2 by HTTP</host><key>aws.ec2.ebs.volume.total_read_time[&quot;{#VOLUME_ID}&quot;]</key></item></graph_item></graph_items></graph_prototype></graph_prototypes><master_item><key>aws.ec2.get_volumes</key></master_item><preprocessing><step><type>JAVASCRIPT</type><parameters><parameter>var result = [];
var volumes = JSON.parse(value);

volumes.forEach(function(volume) {

 result.push({
'{#VOLUME_ID}': volume.volumeId,
'{#VOLUME_TYPE}': volume.volumeType,
  });
});

return JSON.stringify(result);</parameter></parameters></step><step><type>DISCARD_UNCHANGED_HEARTBEAT</type><parameters><parameter>3h</parameter></parameters></step></preprocessing></discovery_rule></discovery_rules><tags><tag><tag>class</tag><value>software</value></tag><tag><tag>target</tag><value>aws</value></tag><tag><tag>target</tag><value>ec2</value></tag></tags><macros><macro><macro>{$AWS.ACCESS.KEY.ID}</macro><description>Access key ID.</description></macro><macro><macro>{$AWS.EBS.BURST.CREDIT.BALANCE.MIN.WARN}</macro><value>20</value><description>Minimum percentage of Byte credits remaining for trigger expression.</description></macro><macro><macro>{$AWS.EBS.BYTE.CREDIT.BALANCE.MIN.WARN}</macro><value>20</value><description>Minimum percentage of Byte credits remaining for trigger expression.</description></macro><macro><macro>{$AWS.EBS.IO.CREDIT.BALANCE.MIN.WARN}</macro><value>20</value><description>Minimum percentage of I/O credits remaining for trigger expression.</description></macro><macro><macro>{$AWS.EC2.CPU.CREDIT.BALANCE.MIN.WARN}</macro><value>50</value><description>Minimum number of free earned CPU credits for trigger expression.</description></macro><macro><macro>{$AWS.EC2.CPU.CREDIT.SURPLUS.BALANCE.MAX.WARN}</macro><value>100</value><description>Maximum number of spent CPU Surplus credits for trigger expression.</description></macro><macro><macro>{$AWS.EC2.CPU.UTIL.WARN.MAX}</macro><value>85</value><description>The warning threshold of the CPU utilization in %.</description></macro><macro><macro>{$AWS.EC2.INSTANCE.ID}</macro><description>EC2 instance ID.</description></macro><macro><macro>{$AWS.EC2.LLD.FILTER.ALARM_NAME.MATCHES}</macro><value>.*</value><description>Filter of discoverable alarms by namespace.</description></macro><macro><macro>{$AWS.EC2.LLD.FILTER.ALARM_NAME.NOT_MATCHES}</macro><value>CHANGE_IF_NEEDED</value><description>Filter to exclude discovered alarms by namespace.</description></macro><macro><macro>{$AWS.EC2.LLD.FILTER.ALARM_SERVICE_NAMESPACE.MATCHES}</macro><value>.*</value><description>Filter of discoverable alarms by namespace.</description></macro><macro><macro>{$AWS.EC2.LLD.FILTER.ALARM_SERVICE_NAMESPACE.NOT_MATCHES}</macro><value>CHANGE_IF_NEEDED</value><description>Filter to exclude discovered alarms by namespace.</description></macro><macro><macro>{$AWS.EC2.LLD.FILTER.VOLUME_TYPE.MATCHES}</macro><value>.*</value><description>Filter of discoverable volumes by type.</description></macro><macro><macro>{$AWS.EC2.LLD.FILTER.VOLUME_TYPE.NOT_MATCHES}</macro><value>CHANGE_IF_NEEDED</value><description>Filter to exclude discovered volumes by type.</description></macro><macro><macro>{$AWS.PROXY}</macro><description>Sets HTTP proxy value. If this macro is empty then no proxy is used.</description></macro><macro><macro>{$AWS.REGION}</macro><value>us-west-1</value><description>Amazon EC2 Region code.</description></macro><macro><macro>{$AWS.SECRET.ACCESS.KEY}</macro><description>Secret access key.</description></macro></macros><valuemaps><valuemap><uuid>50b7fdfdf6de41f4b4b210a07c10cd77</uuid><name>Alarm state</name><mappings><mapping><value>0</value><newvalue>OK</newvalue></mapping><mapping><value>1</value><newvalue>Insufficient data</newvalue></mapping><mapping><value>2</value><newvalue>Alarm</newvalue></mapping><mapping><value>255</value><newvalue>Unknown</newvalue></mapping></mappings></valuemap><valuemap><uuid>d59e4f0c6aaa40bcb5f504f6743d9201</uuid><name>Status check</name><mappings><mapping><value>0</value><newvalue>Passed</newvalue></mapping><mapping><value>1</value><newvalue>Failed</newvalue></mapping></mappings></valuemap><valuemap><uuid>cf0267337f284182a43db45d823824b7</uuid><name>Volume attachment state</name><mappings><mapping><value>0</value><newvalue>Attaching</newvalue></mapping><mapping><value>1</value><newvalue>Attached</newvalue></mapping><mapping><value>2</value><newvalue>Detaching</newvalue></mapping><mapping><value>255</value><newvalue>Unknown</newvalue></mapping></mappings></valuemap><valuemap><uuid>4f31d29791b94e37b065f790609c50b5</uuid><name>Volume status</name><mappings><mapping><value>0</value><newvalue>Creating</newvalue></mapping><mapping><value>1</value><newvalue>Available</newvalue></mapping><mapping><value>2</value><newvalue>In-use</newvalue></mapping><mapping><value>3</value><newvalue>Deleting</newvalue></mapping><mapping><value>4</value><newvalue>Deleted</newvalue></mapping><mapping><value>5</value><newvalue>Error</newvalue></mapping><mapping><value>255</value><newvalue>Unknown</newvalue></mapping></mappings></valuemap></valuemaps></template></templates><graphs><graph><uuid>397c46285f674ac389c59f1c828ae179</uuid><name>AWS EC2: Disk read/write bytes</name><graph_items><graph_item><color>1A7C11</color><item><host>AWS EC2 by HTTP</host><key>aws.ec2.disk.read_bytes.rate</key></item></graph_item><graph_item><sortorder>1</sortorder><color>2774A4</color><item><host>AWS EC2 by HTTP</host><key>aws.ec2.disk_write_bytes.rate</key></item></graph_item></graph_items></graph><graph><uuid>21b7ec1e5e1445e287855e3d1a12c2bc</uuid><name>AWS EC2: Disk read/write rates</name><graph_items><graph_item><color>1A7C11</color><item><host>AWS EC2 by HTTP</host><key>aws.ec2.disk.read_ops.rate</key></item></graph_item><graph_item><sortorder>1</sortorder><color>2774A4</color><item><host>AWS EC2 by HTTP</host><key>aws.ec2.disk_write_ops.rate</key></item></graph_item></graph_items></graph><graph><uuid>a1244a6a4b6641388546988257e905dc</uuid><name>AWS EC2: Network packets</name><graph_items><graph_item><color>1A7C11</color><item><host>AWS EC2 by HTTP</host><key>aws.ec2.packets_in.rate</key></item></graph_item><graph_item><sortorder>1</sortorder><color>2774A4</color><item><host>AWS EC2 by HTTP</host><key>aws.ec2.packets_out.rate</key></item></graph_item></graph_items></graph><graph><uuid>45e96dbc8dff48eeadd18c69b085863f</uuid><name>AWS EC2: Network traffic</name><graph_items><graph_item><color>1A7C11</color><item><host>AWS EC2 by HTTP</host><key>aws.ec2.network_in.rate</key></item></graph_item><graph_item><sortorder>1</sortorder><color>2774A4</color><item><host>AWS EC2 by HTTP</host><key>aws.ec2.network_out.rate</key></item></graph_item></graph_items></graph></graphs></zabbix_export>
